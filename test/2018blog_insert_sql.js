var mockedData = [
    /* 1 */
    {
        "_id" : ObjectId("5881ccd346e5af2588b0997b"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列02— MongoDB 的安装与使用",
        "content" : "## 1.2.1 安装与启动 MongoDB\r\n\r\n- Windows 用户向导：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-windows/\r\n- Linux 用户向导：https://docs.mongodb.com/manual/administration/install-on-linux/\r\n- Mac 用户向导：https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/\r\n\r\n## 1.2.2 Robomongo 和 Mongochef\r\n\r\n#### Robomongo\r\n\r\n[Robomongo](https://robomongo.org/) 是一个基于 Shell 的跨平台开源 MongoDB 可视化管理工具，支持 Windows、Linux 和 Mac，嵌入了 JavaScript 引擎和 MongoDB mongo，只要你会使用 mongo shell，你就会使用 Robomongo，它还提了供语法高亮、自动补全、差别视图等。\r\n\r\n[Robomongo 下载地址](https://robomongo.org/download)\r\n\r\n下载并安装成功后点击左上角的 `Create` 创建一个连接，给该连接起个名字如: `localhost`，使用默认地址（localhost）和端口（27017）即可，点击 `Save` 保存。\r\n\r\n![](/img/markdown_img/1.2.1.png)\r\n\r\n\r\n双击 `localhost` 连接到 MongoDB 并进入交互界面，尝试插入一条数据并查询出来，如下所示:\r\n\r\n![](/img/markdown_img/1.2.2.png)\r\n\r\n\r\n#### MongoChef\r\n\r\n[MongoChef](http://3t.io/mongochef/) 是另一款强大的 MongoDB 可视化管理工具，支持 Windows、Linux 和 Mac。\r\n\r\n[MongoChef 下载地址](http://3t.io/mongochef/#mongochef-download-compare)，我们选择左侧的非商业用途的免费版下载。\r\n\r\n![](/img/markdown_img/1.2.3.png)\r\n\r\n安装成功后跟 Robomongo 一样，也需要创建一个新的连接的配置，成功后双击进入到 MongoChef 主页面，如下所示:\r\n\r\n![](/img/markdown_img/1.2.4.png)\r\n\r\n还可以使用 shell 模式:\r\n\r\n![](/img/markdown_img/1.2.5.png)\r\n\r\n> 小提示: MongoChef 相较于 Robomongo 更强大一些，但 Robomongo 比较轻量也能满足大部分的常规需求，所以哪一个适合自己还需读者自行尝试。\r\n",
        "category" : "xwzj",
        "postSummary" : " 1.2.1 安装与启动 MongoDB\r\n\r\n Windows 用户向导：https://docs.mongodb.com/manual/tutorial/installmongodbonwindo...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 2 */
    {
        "_id" : ObjectId("5881cd4e48242123d8e38ee5"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 03— require",
        "content" : "require 用来加载一个文件的代码，关于 require 的机制这里不展开讲解，请仔细阅读 [官方文档](https://nodejs.org/api/modules.html)。\r\n\r\n简单概括以下几点:\r\n\r\n- require 可加载 .js、.json 和 .node 后缀的文件\r\n- require 的过程是同步的，所以这样是错误的:\r\n```\r\nsetTimeout(() => {\r\n  module.exports = { a: 'hello' };\r\n}, 0);\r\n```\r\nrequire 这个文件得到的是空对象 `{}`\r\n\r\n- require 目录的机制是:\r\n  - 如果目录下有 package.json 并指定了 main 字段，则用之\r\n  - 如果不存在 package.json，则依次尝试加载目录下的 index.js 和 index.node\r\n- require 过的文件会加载到缓存，所以多次 require 同一个文件（模块）不会重复加载\r\n- 判断是否是程序的入口文件有两种方式:\r\n  - require.main === module（推荐）\r\n  - module.parent === null\r\n\r\n\r\n#### 循环引用\r\n\r\n循环引用（或循环依赖）简单点来说就是 a 文件 require 了 b 文件，然后 b 文件又反过来 require 了 a 文件。我们用 a->b 代表 b require 了 a。\r\n\r\n简单的情况:\r\n\r\n```\r\na->b\r\nb->a\r\n```\r\n\r\n复杂点的情况:\r\n\r\n```\r\na->b\r\nb->c\r\nc->a\r\n```\r\n\r\n循环引用并不会报错，导致的结果是 require 的结果是空对象 `{}`，原因是 b require 了 a，a 又去 require 了 b，此时 b 还没初始化好，所以只能拿到初始值 `{}`。当产生循环引用时一般有两种方法解决：\r\n\r\n1. 通过分离共用的代码到另一个文件解决，如上面简单的情况，可拆出共用的代码到 c 中，如下:\r\n\r\n  ```\r\n  c->a\r\n  c->b\r\n  ```\r\n\r\n2. 不在最外层 require，在用到的地方 require，通常在函数的内部\r\n\r\n总的来说，循环依赖的陷阱并不大容易出现，但一旦出现了，对于新手来说还真不好定位。它的存在给我们提了个醒，要时刻注意你项目的依赖关系不要过于复杂，哪天你发现一个你明明已经 exports 了的方法报 `undefined is not a function`，我们就该提醒一下自己：哦，也许是它来了。\r\n\r\n官方示例: [https://nodejs.org/api/modules.html#modules_cycles](https://nodejs.org/api/modules.html#modules_cycles)\r\n\r\n上一节：[1.2 MongoDB 的安装与使用](https://github.com/nswbmw/N-blog/blob/master/book/1.2%20MongoDB%20%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8.md)\r\n\r\n下一节：[2.2 exports 和 module.exports](https://github.com/nswbmw/N-blog/blob/master/book/2.2%20exports%20%E5%92%8C%20module.exports.md)\r\n",
        "category" : "xwzj",
        "postSummary" : "require 用来加载一个文件的代码，关于 require 的机制这里不展开讲解，请仔细阅读 官方文档(https://nodejs.org/api/modules.html)。\r\n\r\n简单概括以下...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 3 */
    {
        "_id" : ObjectId("5881ce22a22fe1252cd57bb8"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 04— exports 和 module.exports",
        "content" : "require 用来加载代码，而 exports 和 module.exports 则用来导出代码。\r\n\r\n很多新手可能会迷惑于 exports 和 module.exports 的区别，为了更好的理解 exports 和 module.exports 的关系，我们先来巩固下 js 的基础。示例：\r\n\r\n**test.js**\r\n\r\n```\r\nvar a = {name: 1};\r\nvar b = a;\r\n\r\nconsole.log(a);\r\nconsole.log(b);\r\n\r\nb.name = 2;\r\nconsole.log(a);\r\nconsole.log(b);\r\n\r\nvar b = {name: 3};\r\nconsole.log(a);\r\nconsole.log(b);\r\n```\r\n\r\n运行 test.js 结果为：\r\n\r\n```\r\n{ name: 1 }\r\n{ name: 1 }\r\n{ name: 2 }\r\n{ name: 2 }\r\n{ name: 2 }\r\n{ name: 3 }\r\n```\r\n\r\n**解释**：a 是一个对象，b 是对 a 的引用，即 a 和 b 指向同一块内存，所以前两个输出一样。当对 b 作修改时，即 a 和 b 指向同一块内存地址的内容发生了改变，所以 a 也会体现出来，所以第三四个输出一样。当 b 被覆盖时，b 指向了一块新的内存，a 还是指向原来的内存，所以最后两个输出不一样。\r\n\r\n明白了上述例子后，我们只需知道三点就知道 exports 和 module.exports 的区别了：\r\n\r\n1. module.exports 初始值为一个空对象 {}\r\n2. exports 是指向的 module.exports 的引用\r\n3. require() 返回的是 module.exports 而不是 exports\r\n\r\nNode.js 官方文档的截图证实了我们的观点:\r\n\r\n![](/img/markdown_img/2.2.1.png)\r\n\r\n#### exports = module.exports = {...}\r\n\r\n我们经常看到这样的写法：\r\n\r\n```\r\nexports = module.exports = {...}\r\n```\r\n\r\n上面的代码等价于:\r\n\r\n```\r\nmodule.exports = {...}\r\nexports = module.exports\r\n```\r\n\r\n原理很简单：module.exports 指向新的对象时，exports 断开了与 module.exports 的引用，那么通过 exports = module.exports 让 exports 重新指向 module.exports。\r\n\r\n> 小提示：ES6 的 import 和 export 不在本文的讲解范围，有兴趣的读者可以去学习阮一峰老师的[《ECMAScript6入门》](http://es6.ruanyifeng.com/)。\r\n",
        "category" : "xwzj",
        "postSummary" : "require 用来加载代码，而 exports 和 module.exports 则用来导出代码。\r\n\r\n很多新手可能会迷惑于 exports 和 module.exports 的区别，为了更好的理...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 3
    },

    /* 4 */
    {
        "_id" : ObjectId("5881ce6f83d6e923a8f6ca59"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 05—Promise",
        "content" : "网上已经有许多关于 Promise 的资料了，这里不在赘述。以下 4 个链接供读者学习：\r\n\r\n1. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise （基础）\r\n2. http://liubin.org/promises-book/ （开源 Promise 迷你书）\r\n3. http://fex.baidu.com/blog/2015/07/we-have-a-problem-with-promises/ （进阶）\r\n4. https://promisesaplus.com/ （官方定义规范）\r\n\r\nPromise 用于异步流程控制，生成器与 yield 也能实现流程控制（基于 co），但不在本教程讲解范围内，读者可参考我的另一部教程 [N-club](https://github.com/nswbmw/N-club)。async/await 结合 Promise 也可以实现流程控制，有兴趣请查阅 [《ECMAScript6入门》](http://es6.ruanyifeng.com/#docs/async#async函数)。\r\n\r\n",
        "category" : "xwzj",
        "postSummary" : "网上已经有许多关于 Promise 的资料了，这里不在赘述。以下 4 个链接供读者学习：\r\n\r\n1. https://developer.mozilla.org/enUS/docs/Web/JavaS...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 5 */
    {
        "_id" : ObjectId("5881ce99aadba01ad052b081"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 06—环境变量",
        "content" : "环境变量不属于 Node.js 的知识范畴，只不过我们在开发 Node.js 应用时经常与环境变量打交道，所以这里简单介绍下。\r\n\r\n环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数。在 Mac 和 Linux 的终端直接输入 env，会列出当前的环境变量，如：USER=xxx。简单来讲，环境变量就是传递参数给运行程序的。\r\n\r\n在 Node.js 中，我们经常这么用:\r\n\r\n```\r\nNODE_ENV=test node app\r\n```\r\n\r\n通过以上命令启动程序，指定当前环境变量 `NODE_ENV` 的值为 test，那么在 app.js 中可通过 `process.env` 来获取环境变量:\r\n\r\n```\r\nconsole.log(process.env.NODE_ENV) //test\r\n```\r\n\r\n另一个常见的例子是使用 [debug](https://www.npmjs.com/package/debug) 模块时:\r\n\r\n```\r\nDEBUG=* node app\r\n```\r\n\r\nWindows 用户需要首先设置环境变量，然后再执行程序：\r\n\r\n```\r\nset DEBUG=*\r\nset NODE_ENV=test\r\nnode app\r\n```\r\n\r\n或者使用 [cross-env](https://www.npmjs.com/package/cross-env)：\r\n\r\n```\r\nnpm i cross-env -g\r\n```\r\n\r\n使用方式：\r\n\r\n```\r\ncross-env NODE_ENV=test node app\r\n```\r\n",
        "category" : "xwzj",
        "postSummary" : "环境变量不属于 Node.js 的知识范畴，只不过我们在开发 Node.js 应用时经常与环境变量打交道，所以这里简单介绍下。\r\n\r\n环境变量（environment variables）一般是指在操...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 6 */
    {
        "_id" : ObjectId("5881cece04dd8005acefe602"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 07—package.json",
        "content" : "package.json 对于 Node.js 应用来说是一个不可或缺的文件，它存储了该 Node.js 应用的名字、版本、描述、作者、入口文件、脚本、版权等等信息。npm 官网有 package.json 每个字段的详细介绍：https://docs.npmjs.com/files/package.json。\r\n\r\n## 2.5.1 semver\r\n\r\n语义化版本（semver）即 dependencies、devDependencies 和 peerDependencies 里的如：`\"co\": \"^4.6.0\"`。\r\n\r\nsemver 格式：`主版本号.次版本号.修订号`。版本号递增规则如下：\r\n\r\n- `主版本号`：做了不兼容的 API 修改\r\n- `次版本号`：做了向下兼容的功能性新增\r\n- `修订号`：做了向下兼容的 bug 修正\r\n\r\n更多阅读：\r\n\r\n1. http://semver.org/lang/zh-CN/\r\n2. http://taobaofed.org/blog/2016/08/04/instructions-of-semver/\r\n\r\n作为 Node.js 的开发者，我们在发布 npm 模块的时候一定要遵守语义化版本的命名规则，即：有 breaking change 发大版本，有新增的功能发小版本，有小的 bug 修复或优化则发修订版本。\r\n",
        "category" : "xwzj",
        "postSummary" : "package.json 对于 Node.js 应用来说是一个不可或缺的文件，它存储了该 Node.js 应用的名字、版本、描述、作者、入口文件、脚本、版权等等信息。npm 官网有 package.j...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : true,
        "pv" : 6
    },

    /* 7 */
    {
        "_id" : ObjectId("5881cf060044e12644265378"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 08— npm 使用注意事项",
        "content" : "## 2.6.1 npm init\r\n\r\n使用 `npm init` 初始化一个空项目是一个好的习惯，即使你对 package.json 及其他属性非常熟悉，`npm init` 也是你开始写新的 Node.js 应用或模块的一个快捷的办法。`npm init` 有智能的默认选项，比如从根目录名称推断模块名称，通过 `~/.npmrc` 读取你的信息，用你的 Git 设置来确定 repository 等等。\r\n\r\n## 2.6.2 npm install\r\n\r\n`npm install` 是我们最常用的 npm 命令之一，因此我们需要好好了解下这个命令。终端输入 `npm install -h` 查看使用方式:\r\n\r\n![](/img/markdown_img/2.6.1.png)\r\n\r\n可以看出：我们通过 `npm install` 可以安装 npm 上发布的某个版本、某个tag、某个版本区间的模块，甚至可以安装本地目录、压缩包和 git/github 的库作为依赖。\r\n\r\n> 小提示: `npm i` 是 `npm install` 的简写，建议使用 `npm i`。\r\n\r\n直接使用 `npm i` 安装的模块是不会写入 package.json 的 dependencies (或 devDependencies)，需要额外加个参数:\r\n\r\n1. `npm i express --save`/`npm i express -S` (安装 express，同时将 `\"express\": \"^4.14.0\"` 写入 dependencies )\r\n2. `npm i express --save-dev`/`npm i express -D` (安装 express，同时将 `\"express\": \"^4.14.0\"` 写入 devDependencies )\r\n3. `npm i express --save --save-exact` (安装 express，同时将 `\"express\": \"4.14.0\"` 写入 dependencies )\r\n\r\n第三种方式将固定版本号写入 dependencies，建议线上的 Node.js 应用都采取这种锁定版本号的方式，因为你不可能保证第三方模块下个小版本是没有验证 bug 的，即使是很流行的模块。拿 Mongoose 来说，Mongoose 4.1.4 引入了一个 bug 导致调用一个文档 entry 的 remove 会删除整个集合的文档，见：[https://github.com/Automattic/mongoose/blob/master/History.md#415--2015-09-01](https://github.com/Automattic/mongoose/blob/master/History.md#415--2015-09-01)。\r\n\r\n> 后面会介绍更安全的 `npm shrinkwrap` 的用法。\r\n\r\n运行以下命令：\r\n\r\n```\r\nnpm config set save-exact true\r\n```\r\n\r\n这样每次 `npm i xxx --save` 的时候会锁定依赖的版本号，相当于加了 `--save-exact` 参数。\r\n\r\n> 小提示：`npm config set` 命令将配置写到了 ~/.npmrc 文件，运行 `npm config list` 查看。\r\n\r\n## 2.6.3 npm scripts\r\n\r\nnpm 提供了灵活而强大的 scripts 功能，见 [官方文档](https://docs.npmjs.com/misc/scripts)。\r\n\r\nnpm 的 scripts 有一些内置的缩写命令，如常用的：\r\n\r\n- `npm start` 等价于 `npm run start` \r\n- `npm test` 等价于 `npm run test` \r\n\r\n## 2.6.4 npm shrinkwrap\r\n\r\n前面说过要锁定依赖的版本，但这并不能完全防止意外情况的发生，因为锁定的只是最外一层的依赖，而里层依赖的模块的 package.json 有可能写的是 `\"mongoose\": \"*\"`。为了彻底锁定依赖的版本，让你的应用在任何机器上安装的都是同样版本的模块（不管嵌套多少层），通过运行 `npm shrinkwrap`，会在当前目录下产生一个 `npm-shrinkwrap.json`，里面包含了通过 node_modules 计算出的模块的依赖树及版本。上面的截图也显示：只要目录下有 npm-shrinkwrap.json 则运行 `npm install` 的时候会优先使用 npm-shrinkwrap.json 进行安装，没有则使用 package.json 进行安装。\r\n\r\n更多阅读：\r\n\r\n1. https://docs.npmjs.com/cli/shrinkwrap\r\n2. http://tech.meituan.com/npm-shrinkwrap.html\r\n\r\n> 注意: 如果 node_modules 下存在某个模块（如直接通过 `npm install xxx` 安装的）而 package.json 中没有，运行 `npm shrinkwrap` 则会报错。另外，`npm shrinkwrap` 只会生成 dependencies 的依赖，不会生成 devDependencies 的。\r\n",
        "category" : "xwzj",
        "postSummary" : " 2.6.1 npm init\r\n\r\n使用 npm init 初始化一个空项目是一个好的习惯，即使你对 package.json 及其他属性非常熟悉，npm init 也是你开始写新的 Node.js...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 4
    },

    /* 8 */
    {
        "_id" : ObjectId("5881cf3cb421ee21acd7cad9"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 09— 初始化一个 Express 项目",
        "content" : "首先，我们新建一个目录 myblog，在该目录下运行 `npm init` 生成一个 package.json，如下所示：\r\n\r\n![](/img/markdown_img/3.1.1.png)\r\n\r\n> 注意：括号里的是默认值，如果使用默认值则直接回车即可，否则输入自定义内容后回车。\r\n\r\n然后安装 express 并写入 package.json：\r\n\r\n```\r\nnpm i express@4.14.0 --save \r\n```\r\n\r\n新建 index.js，添加如下代码：\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.get('/', function(req, res) {\r\n  res.send('hello, express');\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n以上代码的意思是：生成一个 express 实例 app，挂载了一个根路由控制器，然后监听 3000 端口并启动程序。运行 `node index`，打开浏览器访问 `localhost:3000` 时，页面应显示 hello, express。\r\n\r\n这是最简单的一个使用 express 的例子，后面会介绍路由及模板的使用。\r\n\r\n## 3.1.1 supervisor\r\n\r\n在开发过程中，每次修改代码保存后，我们都需要手动重启程序，才能查看改动的效果。使用 [supervisor](https://www.npmjs.com/package/supervisor) 可以解决这个繁琐的问题，全局安装 supervisor：\r\n\r\n```\r\nnpm install -g supervisor\r\n```\r\n\r\n运行 `supervisor --harmony index` 启动程序，如下所示：\r\n\r\n![](/img/markdown_img/3.1.2.png)\r\n\r\nsupervisor 会监听当前目录下 node 和 js 后缀的文件，当这些文件发生改动时，supervisor 会自动重启程序。",
        "category" : "xwzj",
        "postSummary" : "首先，我们新建一个目录 myblog，在该目录下运行 npm init 生成一个 package.json，如下所示：\r\n\r\n/img/markdownimg/3.1.1.png)\r\n\r\n 注意：括号...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 3
    },

    /* 9 */
    {
        "_id" : ObjectId("5881cf816583b823b0aab734"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 10— 路由",
        "content" : "前面我们只是挂载了根路径的路由控制器，现在修改 index.js 如下：\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.get('/', function(req, res) {\r\n  res.send('hello, express');\r\n});\r\n\r\napp.get('/users/:name', function(req, res) {\r\n  res.send('hello, ' + req.params.name);\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n以上代码的意思是：当访问根路径时，依然返回 hello, express，当访问如 `localhost:3000/users/nswbmw` 路径时，返回 hello, nswbmw。路径中 `:name` 起了占位符的作用，这个占位符的名字是 name，可以通过 `req.params.name` 取到实际的值。\r\n\r\n> 小提示：express 使用了 [path-to-regexp](https://www.npmjs.com/package/path-to-regexp) 模块实现的路由匹配。\r\n\r\n不难看出：req 包含了请求来的相关信息，res 则用来返回该请求的响应，更多请查阅 [express 官方文档](http://expressjs.com/en/4x/api.html)。下面介绍几个常用的 req 的属性：\r\n\r\n- `req.query`: 解析后的 url 中的 querystring，如 `?name=haha`，req.query 的值为 `{name: 'haha'}`\r\n- `req.params`: 解析 url 中的占位符，如 `/:name`，访问 /haha，req.params 的值为 `{name: 'haha'}`\r\n- `req.body`: 解析后请求体，需使用相关的模块，如 [body-parser](https://www.npmjs.com/package/body-parser)，请求体为 `{\"name\": \"haha\"}`，则 req.body 为 `{name: 'haha'}`\r\n\r\n## 3.2.1 express.Router\r\n\r\n上面只是很简单的路由使用的例子（将所有路由控制函数都放到了 index.js），但在实际开发中通常有几十甚至上百的路由，都写在 index.js 既臃肿又不好维护，这时可以使用 express.Router 实现更优雅的路由解决方案。在 myblog 目录下创建空文件夹 routes，在 routes 目录下创建 index.js 和 users.js。最后代码如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\nvar indexRouter = require('./routes/index');\r\nvar userRouter = require('./routes/users');\r\n\r\napp.use('/', indexRouter);\r\napp.use('/users', userRouter);\r\n\r\napp.listen(3000);\r\n```\r\n\r\n**routes/index.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nrouter.get('/', function(req, res) {\r\n  res.send('hello, express');\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n**routes/users.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nrouter.get('/:name', function(req, res) {\r\n  res.send('hello, ' + req.params.name);\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n以上代码的意思是：我们将 `/` 和 `/users/:name` 的路由分别放到了 routes/index.js 和 routes/users.js 中，每个路由文件通过生成一个 express.Router 实例 router 并导出，通过 `app.use` 挂载到不同的路径。这两种代码实现了相同的功能，但在实际开发中推荐使用 express.Router 将不同的路由分离到不同的路由文件中。\r\n\r\n更多 express.Router 的用法见 [express 官方文档](http://expressjs.com/en/4x/api.html#router)。",
        "category" : "xwzj",
        "postSummary" : "前面我们只是挂载了根路径的路由控制器，现在修改 index.js 如下：\r\n\r\n\r\nvar express = require('express');\r\nvar app = express();\r\n\r...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 10 */
    {
        "_id" : ObjectId("5881cfb8705b9a06b86785f6"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 11— 模板引擎",
        "content" : "模板引擎（Template Engine）是一个将页面模板和数据结合起来生成 html 的工具。上例中，我们只是返回纯文本给浏览器，现在我们修改代码返回一个 html 页面给浏览器。\r\n\r\n## 3.3.1 ejs\r\n\r\n模板引擎有很多，[ejs](https://www.npmjs.com/package/ejs) 是其中一种，因为它使用起来十分简单，而且与 express 集成良好，所以我们使用 ejs。安装 ejs：\r\n\r\n```\r\nnpm i ejs --save\r\n```\r\n\r\n修改 index.js 如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar path = require('path');\r\nvar express = require('express');\r\nvar app = express();\r\nvar indexRouter = require('./routes/index');\r\nvar userRouter = require('./routes/users');\r\n\r\napp.set('views', path.join(__dirname, 'views'));// 设置存放模板文件的目录\r\napp.set('view engine', 'ejs');// 设置模板引擎为 ejs\r\n\r\napp.use('/', indexRouter);\r\napp.use('/users', userRouter);\r\n\r\napp.listen(3000);\r\n```\r\n\r\n通过 `app.set` 设置模板引擎为 ejs 和存放模板的目录。在 myblog 下新建 views 文件夹，在 views 下新建 users.ejs，添加如下代码：\r\n\r\n**views/users.ejs**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <style type=\"text/css\">\r\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\r\n    </style>\r\n  </head>\r\n  <body>\r\n    <h1><%= name.toUpperCase() %></h1>\r\n    <p>hello, <%= name %></p>\r\n  </body>\r\n</html>\r\n```\r\n\r\n修改 routes/users.js 如下：\r\n\r\n**routes/users.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nrouter.get('/:name', function(req, res) {\r\n  res.render('users', {\r\n    name: req.params.name\r\n  });\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n通过调用 `res.render` 函数渲染 ejs 模板，res.render 第一个参数是模板的名字，这里是 users 则会匹配 views/users.ejs，第二个参数是传给模板的数据，这里传入 name，则在 ejs 模板中可使用 name。`res.render` 的作用就是将模板和数据结合生成 html，同时设置响应头中的 `Content-Type: text/html`，告诉浏览器我返回的是 html，不是纯文本，要按 html 展示。现在我们访问 `localhost:3000/users/haha`，如下图所示：\r\n\r\n![](/img/markdown_img/3.3.1.png)\r\n\r\n上面代码可以看到，我们在模板 `<%= name.toUpperCase() %>` 中使用了 JavaScript 的语法 `.toUpperCase()` 将名字转化为大写，那这个 `<%= xxx %>` 是什么东西呢？ejs 有 3 种常用标签：\r\n\r\n1. `<% code %>`：运行 JavaScript 代码，不输出\r\n2. `<%= code %>`：显示转义后的 HTML内容\r\n3. `<%- code %>`：显示原始 HTML 内容\r\n\r\n> 注意：`<%= code %>` 和 `<%- code %>` 都可以是 JavaScript 表达式生成的字符串，当变量 code 为普通字符串时，两者没有区别。当 code 比如为 `<h1>hello</h1>` 这种字符串时，`<%= code %>` 会原样输出 `<h1>hello</h1>`，而 `<%- code %>` 则会显示 H1 大的 hello 字符串。\r\n\r\n下面的例子解释了 `<% code %>` 的用法：\r\n\r\n**Data**\r\n\r\n```\r\nsupplies: ['mop', 'broom', 'duster']\r\n```\r\n\r\n**Template**\r\n\r\n```\r\n<ul>\r\n<% for(var i=0; i<supplies.length; i++) {%>\r\n   <li><%= supplies[i] %></li>\r\n<% } %>\r\n</ul>\r\n```\r\n\r\n**Result**\r\n\r\n```\r\n<ul>\r\n  <li>mop</li>\r\n  <li>broom</li>\r\n  <li>duster</li>\r\n</ul>\r\n```\r\n\r\n更多 ejs 的标签请看 [官方文档](https://www.npmjs.com/package/ejs#tags)。\r\n\r\n## 3.3.2 includes\r\n\r\n我们使用模板引擎通常不是一个页面对应一个模板，这样就失去了模板的优势，而是把模板拆成可复用的模板片段组合使用，如在 views 下新建 header.ejs 和 footer.ejs，并修改 users.ejs：\r\n\r\n**views/header.ejs**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <style type=\"text/css\">\r\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\r\n    </style>\r\n  </head>\r\n  <body>\r\n```\r\n\r\n**views/footer.ejs**\r\n\r\n```\r\n  </body>\r\n</html>\r\n```\r\n\r\n**views/users.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n  <h1><%= name.toUpperCase() %></h1>\r\n  <p>hello, <%= name %></p>\r\n<%- include('footer') %>\r\n```\r\n\r\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\r\n\r\n> 小提示：拆分模板组件通常有两个好处：\r\n>\r\n> 1. 模板可复用，减少重复代码\r\n> 2. 主模板结构清晰\r\n\r\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`",
        "category" : "xwzj",
        "postSummary" : "模板引擎（Template Engine）是一个将页面模板和数据结合起来生成 html 的工具。上例中，我们只是返回纯文本给浏览器，现在我们修改代码返回一个 html 页面给浏览器。\r\n\r\n 3.3....",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 11 */
    {
        "_id" : ObjectId("5881d00f2408e70ca00b587e"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 12— Express 浅析",
        "content" : "前面我们讲解了 express 中路由和模板引擎 ejs 的用法，但 express 的精髓并不在此，在于中间件的设计理念。\r\n\r\n## 3.4.1 中间件与 next\r\n\r\nexpress 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 `next()` 传递给下一个中间件，如果没有调用 `next()`，则请求不会往下传递，如内置的 `res.render` 其实就是渲染完 html 直接返回给客户端，没有调用 `next()`，从而没有传递给下一个中间件。看个小例子，修改 index.js 如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('1');\r\n  next();\r\n});\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('2');\r\n  res.status(200).end();\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n此时访问 `localhost:3000`，终端会输出：\r\n\r\n```\r\n1\r\n2\r\n```\r\n\r\n通过 `app.use` 加载中间件，在中间件中通过 next 将请求传递到下一个中间件，next 可接受一个参数接收错误信息，如果使用了 `next(error)`，则会返回错误而不会传递到下一个中间件，修改 index.js 如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('1');\r\n  next(new Error('haha'));\r\n});\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('2');\r\n  res.status(200).end();\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n此时访问 `localhost:3000`，终端会输出错误信息：\r\n\r\n![](/img/markdown_img/3.4.1.png)\r\n\r\n浏览器会显示：\r\n\r\n![](/img/markdown_img/3.4.2.png)\r\n\r\n> 小提示：`app.use` 有非常灵活的使用方式，详情见 [官方文档](http://expressjs.com/en/4x/api.html#app.use)。\r\n\r\nexpress 有成百上千的第三方中间件，在开发过程中我们首先应该去 npm 上寻找是否有类似实现的中间件，尽量避免造轮子，节省开发时间。下面给出几个常用的搜索 npm 模块的网站：\r\n\r\n1. [http://npmjs.com](http://npmjs.com)(npm 官网)\r\n2. [http://node-modules.com](http://node-modules.com)\r\n3. [https://npms.io](https://npms.io)\r\n4. [https://nodejsmodules.org](https://nodejsmodules.org)\r\n\r\n> 小提示：express@4 之前的版本基于 connect 这个模块实现的中间件的架构，express@4 及以上的版本则移除了对 connect 的依赖自己实现了，理论上基于 connect 的中间件（通常以 `connect-` 开头，如 `connect-mongo`）仍可结合 express 使用。\r\n\r\n> 注意：中间件的加载顺序很重要！比如：通常把日志中间件放到比较靠前的位置，后面将会介绍的 `connect-flash` 中间件是基于 session 的，所以需要在 `express-session` 后加载。\r\n\r\n## 3.4.2 错误处理\r\n\r\n上面的例子中，应用程序为我们自动返回了错误栈信息（express 内置了一个默认的错误处理器），假如我们想手动控制返回的错误内容，则需要加载一个自定义错误处理的中间件，修改 index.js 如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar app = express();\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('1');\r\n  next(new Error('haha'));\r\n});\r\n\r\napp.use(function(req, res, next) {\r\n  console.log('2');\r\n  res.status(200).end();\r\n});\r\n\r\n//错误处理\r\napp.use(function(err, req, res, next) {\r\n  console.error(err.stack);\r\n  res.status(500).send('Something broke!');\r\n});\r\n\r\napp.listen(3000);\r\n```\r\n\r\n此时访问 `localhost:3000`，浏览器会显示 `Something broke!`。\r\n\r\n> 小提示：关于 express 的错误处理，详情见 [官方文档](http://expressjs.com/en/guide/error-handling.html)。",
        "category" : "xwzj",
        "postSummary" : "前面我们讲解了 express 中路由和模板引擎 ejs 的用法，但 express 的精髓并不在此，在于中间件的设计理念。\r\n\r\n 3.4.1 中间件与 next\r\n\r\nexpress 中的中间件（...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 12 */
    {
        "_id" : ObjectId("5881d0488d88620b945d1a59"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 13— 开发环境",
        "content" : "从本章开始，正式学习如何使用 Express + MongoDB 搭建一个博客。\r\n\r\n#### Node.js: `6.9.1`\r\n#### MongoDB: `3.2.10`\r\n#### Express: `4.14.0`\r\n",
        "category" : "xwzj",
        "postSummary" : "从本章开始，正式学习如何使用 Express  MongoDB 搭建一个博客。\r\n\r\n Node.js: 6.9.1\r\n MongoDB: 3.2.10\r\n Express: 4.14.0\r\n...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 3
    },

    /* 13 */
    {
        "_id" : ObjectId("5881efd82d5eab0344234a54"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 01— Node.js 的安装与使用",
        "content" : "## 1.1.1 安装 Node.js\r\n\r\n有三种方式安装 Node.js：一是通过安装包安装，二是通过源码编译安装，三是在 Linux 下可以通过 yum|apt-get 安装，在 Mac 下可以通过 [Homebrew](http://brew.sh/) 安装。对于 Windows 和 Mac 用户，推荐使用安装包安装，Linux 用户推荐使用源码编译安装。\r\n\r\n#### Windows 和 Mac 安装：\r\n\r\n**第一步：**\r\n\r\n打开 [Node.js 官网](https://nodejs.org/en/)，可以看到以下两个下载选项：\r\n\r\n![](/img/markdown_img/1.1.1.png)\r\n\r\n左边的是 LTS 版，用过 ubuntu 的同学可能比较熟悉，即长期支持版本，大多数人用这个就可以了。右边是最新版，支持最新的语言特性（比如对 ES6 的支持更全面），想尝试新特性的开发者可以安装这个版本。我们选择左边的 v6.9.1 LTS 点击下载。\r\n\r\n> 小提示：从 [http://node.green](http://node.green) 上可以看到 Node.js 各个版本对 ES6 的支持情况。\r\n\r\n**第二步：**\r\n\r\n安装 Node.js，这个没什么好说的，一直点击 `继续` 即可。\r\n\r\n![](/img/markdown_img/1.1.2.png)\r\n\r\n**第三步：**\r\n\r\n提示安装成功后，打开终端输入以下命令，可以看到 node 和 npm 都已经安装好了：\r\n\r\n![](/img/markdown_img/1.1.3.png)\r\n\r\n#### Linux 安装：\r\n\r\nLinux 用户可通过源码编译安装：\r\n\r\n```\r\ncurl -O https://nodejs.org/dist/v6.9.1/node-v6.9.1.tar.gz\r\ntar -xzvf node-v6.9.1.tar.gz\r\ncd node-v6.9.1\r\n./configure\r\nmake\r\nmake install\r\n```\r\n\r\n> 注意: 如果编译过程报错，可能是缺少某些依赖包。因为报错内容不尽相同，请读者自行求助搜索引擎或 [stackoverflow](http://stackoverflow.com/)。\r\n\r\n## 1.1.2 n 和 nvm\r\n\r\n通常我们使用稳定的 LTS 版本的 Node.js 即可，但有的情况下我们又想尝试一下新的特性，我们总不能来回安装不同版本的 Node.js 吧，这个时候我们就需要 [n](https://github.com/tj/n) 或者 [nvm](https://github.com/creationix/nvm) 了。n 和 nvm 是两个常用的 Node.js 版本管理工具，关于 n 和 nvm 的使用以及区别，[这篇文章](http://taobaofed.org/blog/2015/11/17/nvm-or-n/) 讲得特别详细，这里不再赘述。\r\n\r\n## 1.1.3 nrm\r\n\r\n[nrm](https://github.com/Pana/nrm) 是一个管理 npm 源的工具。用过 ruby 和 gem 的同学会比较熟悉，通常我们会把 gem 源切到国内的淘宝镜像，这样在安装和更新一些包的时候比较快。nrm 同理，用来切换官方 npm 源和国内的 npm 源（如: [cnpm](http://cnpmjs.org/)），当然也可以用来切换官方 npm 源和公司私有 npm 源。\r\n\r\n全局安装 nrm:\r\n\r\n```\r\nnpm i nrm -g\r\n```\r\n\r\n查看当前 nrm 内置的几个 npm 源的地址：\r\n\r\n![](/img/markdown_img/1.1.4.png)\r\n\r\n切换到 cnpm：\r\n\r\n![](/img/markdown_img/1.1.5.png)\r\n",
        "category" : "xwzj",
        "postSummary" : " 1.1.1 安装 Node.js\r\n\r\n有三种方式安装 Node.js：一是通过安装包安装，二是通过源码编译安装，三是在 Linux 下可以通过 yum|aptget 安装，在 Mac 下可以通过 ...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 1
    },

    /* 14 */
    {
        "_id" : ObjectId("5881f2fcd02d2020e0d55544"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 26 — 部署",
        "content" : "## 4.15.1 申请 MLab\r\n\r\n[MLab](https://mlab.com) (前身是 MongoLab) 是一个 mongodb 云数据库提供商，我们可以选择 500MB 空间的免费套餐用来测试。注册成功后，点击右上角的 `Create New` 创建一个数据库（如: myblog），成功后点击进入到该数据库详情页，注意页面中有一行黄色的警告：\r\n\r\n```\r\nA database user is required to connect to this database. To create one now, visit the 'Users' tab and click the 'Add database user' button.\r\n```\r\n\r\n每个数据库至少需要一个 user，所以我们点击 Users 下的 `Add database user` 创建一个用户。\r\n\r\n> 注意：不要选中 `Make read-only`，因为我们有写数据库的操作。\r\n\r\n最后分配给我们的类似下面的 mongodb url：\r\n\r\n```\r\nmongodb://<dbuser>:<dbpassword>@ds139327.mlab.com:39327/myblog\r\n```\r\n\r\n如我创建的用户名和密码都为 myblog 的用户，新建 config/production.js，添加如下代码：\r\n\r\n**config/production.js**\r\n\r\n```\r\nmodule.exports = {\r\n  mongodb: 'mongodb://myblog:myblog@ds139327.mlab.com:39327/myblog'\r\n};\r\n```\r\n\r\n停止程序，然后以 production 配置启动程序:\r\n\r\n```\r\nNODE_ENV=production supervisor --harmony index\r\n```\r\n\r\n> 注意：Windows 用户安装 [cross-env](https://www.npmjs.com/package/cross-env)，使用：\r\n> ```\r\n> cross-env NODE_ENV=production supervisor --harmony index\r\n> ```\r\n\r\n## 4.15.2 pm2\r\n\r\n当我们的博客要部署到线上服务器时，不能单纯的靠 `node index` 或者 `supervisor index` 来启动了，因为我们断掉 SSH 连接后服务就终止了，这时我们就需要像 [pm2](https://www.npmjs.com/package/pm2) 或者 [forever](https://www.npmjs.com/package/forever) 这样的进程管理器了。pm2 是 Node.js 下的生产环境进程管理工具，就是我们常说的进程守护工具，可以用来在生产环境中进行自动重启、日志记录、错误预警等等。以 pm2 为例，全局安装 pm2：\r\n\r\n```\r\nnpm install pm2 -g\r\n```\r\n\r\n修改 package.json，添加 start 的命令：\r\n\r\n**package.json**\r\n\r\n```\r\n\"scripts\": {\r\n  \"test\": \"node --harmony ./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha\",\r\n  \"start\": \"NODE_ENV=production pm2 start index.js --node-args='--harmony' --name 'myblog'\"\r\n}\r\n```\r\n\r\n然后运行 `npm start` 通过 pm2 启动程序，如下图所示 ：\r\n\r\n![](/img/markdown_img/4.15.1.png)\r\n\r\npm2 常用命令:\r\n\r\n1. `pm2 start/stop`: 启动/停止程序\r\n2. `pm2 reload/restart [id|name]`: 重启程序\r\n3. `pm2 logs [id|name]`: 查看日志\r\n4. `pm2 l/list`: 列出程序列表\r\n\r\n更多命令请使用 `pm2 -h` 查看。\r\n\r\n## 4.15.2 部署到 Heroku\r\n\r\n[Heroku](www.heroku.com) 是一个支持多种编程语言的云服务平台，Heroku 也提供免费的基础套餐供开发者测试使用。现在，我们将论坛部署到 Heroku。\r\n\r\n> 注意：新版 heroku 会有填写信用卡的步骤，如果没有请跳过本节。\r\n\r\n首先，需要到 [https://toolbelt.heroku.com/](https://toolbelt.heroku.com/) 下载安装 Heroku 的命令行工具包 toolbelt。然后登录（如果没有账号，请注册）到 Heroku 的 Dashboard，点击右上角 New -> Create New App 创建一个应用。创建成功后运行：\r\n\r\n```\r\n$ heroku login\r\n```\r\n\r\n填写正确的 email 和 password 验证通过后，本地会产生一个 SSH public key。在部署到 Heroku 之前，我们需要对代码进行简单的修改。如下：\r\n\r\n1. 删掉 .gitignore 中：\r\n```\r\nconfig/*\r\n!config/default.*\r\n```\r\n因为我们无法登录到 Heroku 主机创建 production 配置文件，所以这里将 production 配置也上传到 Heroku。\r\n\r\n2. 打开 index.js，将 `app.listen` 修改为：\r\n```\r\nconst port = process.env.PORT || config.port;\r\napp.listen(port, function () {\r\n  console.log(`${pkg.name} listening on port ${port}`);\r\n});\r\n```\r\n因为 Heroku 会动态分配端口，所以不能用配置文件里写死的端口。\r\n\r\n3. 在根目录下新建 Procfile 文件，添加如下内容：\r\n```\r\nweb: npm start\r\n```\r\nProcfile 文件告诉 Heroku 该使用什么命令启动一个 web 服务。更多见：https://devcenter.heroku.com/articles/getting-started-with-nodejs。\r\n\r\n然后输入以下命令：\r\n\r\n```\r\n$ git init\r\n$ heroku git:remote -a 你的应用名称\r\n$ git add .\r\n$ git commit -am \"first blood\"\r\n$ git push heroku master\r\n```\r\n\r\n稍后，我们的论坛就部署成功了。访问：\r\n\r\n```\r\nhttps://你的应用名称.herokuapp.com/\r\n```\r\n\r\n## 4.15.3 部署到 UCloud\r\n\r\n[UCloud](https://www.ucloud.cn/) 是国内的一家云计算服务商，接下来我们尝试将博客搭在 UCloud 上。\r\n\r\n#### 创建主机\r\n\r\n1. 注册 UCloud\r\n2. 点击左侧的 `云主机`，然后点击 `创建主机`，统统选择最低配置\r\n3. 右侧付费方式选择 `按时`（每小时），点击 `立即购买`\r\n4. 在支付确认页面，点击 `确认支付`\r\n\r\n购买成功后回到主机管理列表，如下所示：\r\n\r\n![](/img/markdown_img/4.15.2.png)\r\n\r\n> 注意：下面所有的 ip 都替换为你自己的外网 ip。\r\n\r\n#### 环境搭建与部署\r\n\r\n修改 config/production.js，将 port 修改为 80 端口：\r\n\r\n**config/production.js**\r\n\r\n```\r\nmodule.exports = {\r\n  port: 80,\r\n  mongodb: 'mongodb://myblog:myblog@ds139327.mlab.com:39327/myblog'\r\n};\r\n```\r\n\r\n登录主机，用刚才设置的密码：\r\n\r\n```\r\nssh root@106.75.47.229\r\n```\r\n\r\n因为是 CentOS 系统，所以我选择使用 yum 安装，而不是下载源码编译安装：\r\n\r\n```\r\nyum install git #安装git\r\nyum install nodejs #安装 Node.js\r\nyum install npm #安装 npm\r\n\r\nnpm i npm -g #升级 npm\r\nnpm i pm2 -g #安装 pm2\r\nnpm i n -g #安装 n\r\nn v6.9.1 #安装 v6.9.1 版本的 Node.js\r\nn use 6.9.1 #使用 v6.9.1 版本的 Node.js\r\nnode -v\r\n```\r\n> 注意：如果 `node -v` 显示的不是 6.9.1，则断开 ssh，重新登录主机再试试。\r\n\r\n此时应该在 `/root` 目录下，运行以下命令：\r\n```\r\ngit clone https://github.com/nswbmw/N-blog.git myblog #或在本机 myblog 目录下运行 rsync -av --exclude=\"node_modules\" ./ root@106.75.47.229:/root/myblog\r\ncd myblog\r\nnpm i\r\nnpm start\r\npm2 logs\r\n```\r\n> 注意：如果不想用 git 的形式将代码拉到云主机上，可以用 rsync 将本地的代码同步到你的 UCloud 主机上，如上所示。\r\n\r\n最后，访问你的公网 ip 地址试试吧，如下所示：\r\n\r\n![](/img/markdown_img/4.15.3.png)\r\n\r\n> 小提示：绑定域名不在本节讲解范围，读者可自行尝试。\r\n\r\n> 小提示：因为我们选择的按时付费套餐，测试完成后，可在主机管理页面选择关闭主机，节约费用。\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.2.1 目录结构\r\n\r\n我们停止 supervisor 并删除 myblog 目录从头来过。重新创建 myblog，运行 npm init，如下：\r\n\r\n(/img/markdownimg/4....",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : true,
        "pv" : 21
    },

    /* 15 */
    {
        "_id" : ObjectId("5881f66328550d2118f28cb7"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 25— 测试",
        "content" : "## 4.14.1 mocha 和 supertest\r\n\r\n[mocha](https://www.npmjs.com/package/mocha) 和 [suptertest](https://www.npmjs.com/package/supertest) 是常用的测试组合，通常用来测试 restful 的 api 接口，这里我们也可以用来测试我们的博客应用。在 myblog 下新建 test 文件夹存放测试文件，以注册为例讲解 mocha 和 supertest 的用法。首先安装所需模块：\r\n\r\n```\r\nnpm i mocha supertest --save\r\n```\r\n\r\n修改 package.json，将：\r\n\r\n**package.json**\r\n\r\n```\r\n\"scripts\": {\r\n  \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\r\n}\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n\"scripts\": {\r\n  \"test\": \"mocha --harmony test\"\r\n}\r\n```\r\n\r\n指定执行 test 目录的测试。修改 index.js，将：\r\n\r\n**index.js**\r\n\r\n```\r\n// 监听端口，启动程序\r\napp.listen(config.port, function () {\r\n  console.log(`${pkg.name} listening on port ${config.port}`);\r\n});\r\n```\r\n\r\n修改为:\r\n\r\n```\r\nif (module.parent) {\r\n  module.exports = app;\r\n} else {\r\n  // 监听端口，启动程序\r\n  app.listen(config.port, function () {\r\n    console.log(`${pkg.name} listening on port ${config.port}`);\r\n  });\r\n}\r\n```\r\n\r\n这样做可以实现：直接启动 index.js 则会监听端口启动程序，如果 index.js 被 require 了，则导出 app，通常用于测试。\r\n\r\n找一张图片用于测试上传头像，放到 test 目录下，如 avatar.png。新建 test/signup.js，添加如下测试代码：\r\n\r\n**test/signup.js**\r\n\r\n```\r\nvar path = require('path');\r\nvar assert = require('assert');\r\nvar request = require('supertest');\r\nvar app = require('../index');\r\nvar User = require('../lib/mongo').User;\r\n\r\ndescribe('signup', function() {\r\n  describe('POST /signup', function() {\r\n    var agent = request.agent(app);//persist cookie when redirect\r\n    beforeEach(function (done) {\r\n      // 创建一个用户\r\n      User.create({\r\n        name: 'aaa',\r\n        password: '123456',\r\n        avatar: '',\r\n        gender: 'x',\r\n        bio: ''\r\n      })\r\n      .exec()\r\n      .then(function () {\r\n        done();\r\n      })\r\n      .catch(done);\r\n    });\r\n\r\n    afterEach(function (done) {\r\n      // 清空 users 表\r\n      User.remove({})\r\n        .exec()\r\n        .then(function () {\r\n          done();\r\n        })\r\n        .catch(done);\r\n    });\r\n\r\n    // 名户名错误的情况\r\n    it('wrong name', function(done) {\r\n      agent\r\n        .post('/signup')\r\n        .type('form')\r\n        .attach('avatar', path.join(__dirname, 'avatar.png'))\r\n        .field({ name: '' })\r\n        .redirects()\r\n        .end(function(err, res) {\r\n          if (err) return done(err);\r\n          assert(res.text.match(/名字请限制在 1-10 个字符/));\r\n          done();\r\n        });\r\n    });\r\n\r\n    // 性别错误的情况\r\n    it('wrong gender', function(done) {\r\n      agent\r\n        .post('/signup')\r\n        .type('form')\r\n        .attach('avatar', path.join(__dirname, 'avatar.png'))\r\n        .field({ name: 'nswbmw', gender: 'a' })\r\n        .redirects()\r\n        .end(function(err, res) {\r\n          if (err) return done(err);\r\n          assert(res.text.match(/性别只能是 m、f 或 x/));\r\n          done();\r\n        });\r\n    });\r\n    // 其余的参数测试自行补充\r\n    // 用户名被占用的情况\r\n    it('duplicate name', function(done) {\r\n      agent\r\n        .post('/signup')\r\n        .type('form')\r\n        .attach('avatar', path.join(__dirname, 'avatar.png'))\r\n        .field({ name: 'aaa', gender: 'm', bio: 'noder', password: '123456', repassword: '123456' })\r\n        .redirects()\r\n        .end(function(err, res) {\r\n          if (err) return done(err);\r\n          assert(res.text.match(/用户名已被占用/));\r\n          done();\r\n        });\r\n    });\r\n\r\n    // 注册成功的情况\r\n    it('success', function(done) {\r\n      agent\r\n        .post('/signup')\r\n        .type('form')\r\n        .attach('avatar', path.join(__dirname, 'avatar.png'))\r\n        .field({ name: 'nswbmw', gender: 'm', bio: 'noder', password: '123456', repassword: '123456' })\r\n        .redirects()\r\n        .end(function(err, res) {\r\n          if (err) return done(err);\r\n          assert(res.text.match(/注册成功/));\r\n          done();\r\n        });\r\n    });\r\n  });\r\n});\r\n```\r\n\r\n运行 `npm test` 看看效果吧，其余的测试请读者自行完成。\r\n\r\n## 4.14.2 测试覆盖率\r\n\r\n我们写测试肯定想覆盖所有的情况（包括各种出错的情况及正确时的情况），但光靠想需要写哪些测试是不行的，总也会有疏漏，最简单的办法就是可以直观的看出测试是否覆盖了所有的代码，这就是测试覆盖率，即被测试覆盖到的代码行数占总代码行数的比例。\r\n\r\n> 注意：即使测试覆盖率达到 100% 也不能说明你的测试覆盖了所有的情况，只能说明基本覆盖了所有的情况。\r\n\r\n[istanbul](https://www.npmjs.com/package/istanbul) 是一个常用的生成测试覆盖率的库，它会将测试的结果报告生成 html 页面，并放到项目根目录的 coverage 目录下。首先安装 istanbul:\r\n\r\n```\r\nnpm i istanbul --save-dev\r\n```\r\n\r\n配置 istanbul 很简单，将 package.json 中：\r\n\r\n**package.json**\r\n\r\n```\r\n\"scripts\": {\r\n  \"test\": \"mocha --harmony test\"\r\n}\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n\"scripts\": {\r\n  \"test\": \"node --harmony ./node_modules/.bin/istanbul cover ./node_modules/.bin/_mocha\"\r\n}\r\n```\r\n\r\n> 注意：如果 Windows 下报错，尝试修改为：\r\n> ```\r\n> \"scripts\": {\r\n>   \"test\": \"node --harmony ./node_modules/istanbul/lib/cli.js cover ./node_modules/mocha/bin/_mocha\"\r\n> }\r\n> ```\r\n> 见 [#201](https://github.com/nswbmw/N-blog/issues/201).\r\n\r\n即可将 mocha 和 istanbul 结合使用，终端会打印：\r\n\r\n![](/img/markdown_img/4.14.1.png)\r\n\r\n打开 myblog/coverage/Icov-report/index.html，如下所示：\r\n\r\n![](/img/markdown_img/4.14.2.png)\r\n\r\n可以点进去查看某个代码文件具体的覆盖率，如下所示：\r\n\r\n![](/img/markdown_img/4.14.3.png)\r\n\r\n红色的行表示测试没有覆盖到，因为我们只写了 name 和 gender 的测试。",
        "category" : "xwzj",
        "postSummary" : " 4.14.1 mocha 和 supertest\r\n\r\nmocha(https://www.npmjs.com/package/mocha) 和 suptertest(https://www.npm...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 26
    },

    /* 16 */
    {
        "_id" : ObjectId("5881f6bf287e8b2524e372d4"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 24 — 日志",
        "content" : "现在我们来实现日志功能，日志分为正常请求的日志和错误请求的日志，这两种日志都打印到终端并写入文件。\r\n\r\n## 4.13.1 winston 和 express-winston\r\n\r\n我们使用 [winston](https://www.npmjs.com/package/winston) 和 [express-winston](https://www.npmjs.com/package/express-winston) 记录日志。新建 logs 目录存放日志文件，修改 index.js，在：\r\n\r\n**index.js**\r\n\r\n```\r\nvar pkg = require('./package');\r\n```\r\n\r\n下引入所需模块：\r\n\r\n```\r\nvar winston = require('winston');\r\nvar expressWinston = require('express-winston');\r\n```\r\n\r\n将：\r\n\r\n```\r\n// 路由\r\nroutes(app);\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// 正常请求的日志\r\napp.use(expressWinston.logger({\r\n  transports: [\r\n    new (winston.transports.Console)({\r\n      json: true,\r\n      colorize: true\r\n    }),\r\n    new winston.transports.File({\r\n      filename: 'logs/success.log'\r\n    })\r\n  ]\r\n}));\r\n// 路由\r\nroutes(app);\r\n// 错误请求的日志\r\napp.use(expressWinston.errorLogger({\r\n  transports: [\r\n    new winston.transports.Console({\r\n      json: true,\r\n      colorize: true\r\n    }),\r\n    new winston.transports.File({\r\n      filename: 'logs/error.log'\r\n    })\r\n  ]\r\n}));\r\n```\r\n\r\n可以看出：我们将正常请求的日志打印到终端并写入了 `logs/success.log`，将错误请求的日志打印到终端并写入了 `logs/error.log`。需要注意的是：记录正常请求日志的中间件要放到 `routes(app)` 之前，记录错误请求日志的中间件要放到 `routes(app)` 之后。\r\n\r\n## 4.13.2 .gitignore\r\n\r\n如果我们想把项目托管到 git 服务器上（如: [GitHub](https://github.com)），而不想把线上配置、本地调试的 logs 以及 node_modules 添加到 git 的版本控制中，这个时候就需要 .gitignore 文件了，git 会读取 .gitignore 并忽略这些文件。在 myblog 下新建 .gitignore 文件，添加如下配置：\r\n\r\n**.gitignore**\r\n\r\n```\r\nconfig/*\r\n!config/default.*\r\nnpm-debug.log\r\nnode_modules\r\ncoverage\r\n```\r\n\r\n需要注意的是，通过设置：\r\n\r\n```\r\nconfig/*\r\n!config/default.*\r\n```\r\n\r\n这样只有 config/default.js 会加入 git 的版本控制，而 config 目录下的其他配置文件则会被忽略，因为把线上配置加入到 git 是一个不太安全的行为，通常你需要去线上环境手动创建 config/production.js，然后添加一些线上的配置（如：mongodb url）即可覆盖相应的 default 配置。\r\n\r\n> 注意：后面讲到部署到 Heroku 时，因为无法登录到 Heroku 主机，所以可以把以下两行删掉，将 config/production.js 也加入 git 中。\r\n> \r\n> ```\r\n> config/*\r\n> !config/default.*\r\n> ```\r\n\r\n然后在 public/img 目录下创建 .gitignore：\r\n\r\n```\r\n# Ignore everything in this directory\r\n*\r\n# Except this file\r\n!.gitignore\r\n```\r\n\r\n这样 git 会忽略 public/img 目录下所有上传的头像，而不忽略 public/img 目录。同理，在 logs 目录下创建 .gitignore 忽略日志文件：\r\n\r\n```\r\n# Ignore everything in this directory\r\n*\r\n# Except this file\r\n!.gitignore\r\n```",
        "category" : "xwzj",
        "postSummary" : "现在我们来实现日志功能，日志分为正常请求的日志和错误请求的日志，这两种日志都打印到终端并写入文件。\r\n\r\n 4.13.1 winston 和 expresswinston\r\n\r\n我们使用 winsto...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 10
    },

    /* 17 */
    {
        "_id" : ObjectId("5881f704127e6f23708ae297"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 23 — 错误页面",
        "content" : "前面讲到 express 有一个内置的错误处理逻辑，如果程序出错，会直接将错误栈返回并显示到页面上。现在我们来自己写一个错误页面，新建 views/error.ejs，添加如下代码：\r\n\r\n**views/error.ejs**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <title><%= blog.title %></title>\r\n    <link rel=\"stylesheet\" href=\"/css/style.css\">\r\n  </head>\r\n  <body>\r\n    <h2><%= error.message %></h2>\r\n    <p><%= error.stack %></p>\r\n  </body>\r\n</html>\r\n```\r\n\r\n修改 index.js，在 `app.listen` 上一行添加如下代码：\r\n\r\n**index.js**\r\n\r\n```\r\n// error page\r\napp.use(function (err, req, res, next) {\r\n  res.render('error', {\r\n    error: err\r\n  });\r\n});\r\n```",
        "category" : "xwzj",
        "postSummary" : "前面讲到 express 有一个内置的错误处理逻辑，如果程序出错，会直接将错误栈返回并显示到页面上。现在我们来自己写一个错误页面，新建 views/error.ejs，添加如下代码：\r\n\r\nviews...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 4
    },

    /* 18 */
    {
        "_id" : ObjectId("5881f73a265ffe27a4704473"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 22— 404页面",
        "content" : "现在访问一个不存在的地址，如：`http://localhost:3000/haha` 页面会显示：\r\n\r\n```\r\nCannot GET /haha\r\n```\r\n\r\n我们来自定义 404 页面。修改 routes/index.js，在：\r\n\r\n**routes/index.js**\r\n\r\n```\r\napp.use('/posts', require('./posts'));\r\n```\r\n\r\n下添加如下代码：\r\n\r\n```\r\n// 404 page\r\napp.use(function (req, res) {\r\n  if (!res.headersSent) {\r\n    res.render('404');\r\n  }\r\n});\r\n```\r\n\r\n新建 views/404.ejs，添加如下代码：\r\n\r\n**views/404.ejs**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <title><%= blog.title %></title>\r\n    <script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\"></script>\r\n  </head>\r\n  <body></body>\r\n</html>\r\n```\r\n\r\n这里我们只为了演示 express 中处理 404 的情况，用了腾讯公益的 404 页面。\r\n",
        "category" : "xwzj",
        "postSummary" : "现在访问一个不存在的地址，如：http://localhost:3000/haha 页面会显示：\r\n\r\n\r\nCannot GET /haha\r\n\r\n\r\n我们来自定义 404 页面。修改 routes/...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 19 */
    {
        "_id" : ObjectId("5881f75747326914d893838d"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 21— 留言",
        "content" : "## 4.10.1 留言模型设计\r\n\r\n我们只需要留言的作者 id、留言内容和关联的文章 id 这几个字段，修改 lib/mongo.js，添加如下代码：\r\n\r\n**lib/mongo.js**\r\n\r\n```\r\nexports.Comment = mongolass.model('Comment', {\r\n  author: { type: Mongolass.Types.ObjectId },\r\n  content: { type: 'string' },\r\n  postId: { type: Mongolass.Types.ObjectId }\r\n});\r\nexports.Comment.index({ postId: 1, _id: 1 }).exec();// 通过文章 id 获取该文章下所有留言，按留言创建时间升序\r\nexports.Comment.index({ author: 1, _id: 1 }).exec();// 通过用户 id 和留言 id 删除一个留言\r\n```\r\n\r\n## 4.10.2 显示留言\r\n\r\n在实现留言功能之前，我们先让文章页可以显示留言列表。首先创建留言的模板，新建 views/components/comments.ejs，添加如下代码：\r\n\r\n**views/components/comments.ejs**\r\n\r\n```\r\n<div class=\"ui grid\">\r\n  <div class=\"four wide column\"></div>\r\n  <div class=\"eight wide column\">\r\n    <div class=\"ui segment\">\r\n      <div class=\"ui minimal comments\">\r\n        <h3 class=\"ui dividing header\">留言</h3>\r\n\r\n        <% comments.forEach(function (comment) { %>\r\n          <div class=\"comment\">\r\n            <span class=\"avatar\">\r\n              <img src=/img/markdown_img/<%= comment.author.avatar %>\">\r\n            </span>\r\n            <div class=\"content\">\r\n              <a class=\"author\" href=\"/posts?author=<%= comment.author._id %>\"><%= comment.author.name %></a>\r\n              <div class=\"metadata\">\r\n                <span class=\"date\"><%= comment.created_at %></span>\r\n              </div>\r\n              <div class=\"text\"><%- comment.content %></div>\r\n\r\n              <% if (user && comment.author._id && user._id.toString() === comment.author._id.toString()) { %>\r\n                <div class=\"actions\">\r\n                  <a class=\"reply\" href=\"/posts/<%= post._id %>/comment/<%= comment._id %>/remove\">删除</a>\r\n                </div>\r\n              <% } %>\r\n            </div>\r\n          </div>\r\n        <% }) %>\r\n\r\n        <% if (user) { %>\r\n          <form class=\"ui reply form\" method=\"post\" action=\"/posts/<%= post._id %>/comment\">\r\n            <div class=\"field\">\r\n              <textarea name=\"content\"></textarea>\r\n            </div>\r\n            <input type=\"submit\" class=\"ui icon button\" value=\"留言\" />\r\n          </form>\r\n        <% } %>\r\n\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n在文章页引入留言的模板片段，修改 views/post.ejs 为：\r\n\r\n**views/post.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n\r\n<%- include('components/post-content') %>\r\n<%- include('components/comments') %>\r\n\r\n<%- include('footer') %>\r\n```\r\n\r\n新建 models/comments.js，添加如下代码：\r\n\r\n**models/comments.js**\r\n\r\n```\r\nvar marked = require('marked');\r\nvar Comment = require('../lib/mongo').Comment;\r\n\r\n// 将 comment 的 content 从 markdown 转换成 html\r\nComment.plugin('contentToHtml', {\r\n  afterFind: function (comments) {\r\n    return comments.map(function (comment) {\r\n      comment.content = marked(comment.content);\r\n      return comment;\r\n    });\r\n  }\r\n});\r\n\r\nmodule.exports = {\r\n  // 创建一个留言\r\n  create: function create(comment) {\r\n    return Comment.create(comment).exec();\r\n  },\r\n\r\n  // 通过用户 id 和留言 id 删除一个留言\r\n  delCommentById: function delCommentById(commentId, author) {\r\n    return Comment.remove({ author: author, _id: commentId }).exec();\r\n  },\r\n\r\n  // 通过文章 id 删除该文章下所有留言\r\n  delCommentsByPostId: function delCommentsByPostId(postId) {\r\n    return Comment.remove({ postId: postId }).exec();\r\n  },\r\n\r\n  // 通过文章 id 获取该文章下所有留言，按留言创建时间升序\r\n  getComments: function getComments(postId) {\r\n    return Comment\r\n      .find({ postId: postId })\r\n      .populate({ path: 'author', model: 'User' })\r\n      .sort({ _id: 1 })\r\n      .addCreatedAt()\r\n      .contentToHtml()\r\n      .exec();\r\n  },\r\n\r\n  // 通过文章 id 获取该文章下留言数\r\n  getCommentsCount: function getCommentsCount(postId) {\r\n    return Comment.count({ postId: postId }).exec();\r\n  }\r\n};\r\n```\r\n\r\n> 小提示：我们让留言也支持了 markdown。\r\n\r\n> 注意：其实通过 commentId 就可以唯一确定并删除一条留言，添加 author 的限制是为了防止用户删除他人的留言。\r\n> 注意：删除一篇文章成功后也要删除该文章下所有的评论，上面 delCommentsByPostId 就是用来做这件事的。\r\n\r\n\r\n修改 models/posts.js，在：\r\n\r\n**models/posts.js**\r\n\r\n```\r\nvar Post = require('../lib/mongo').Post;\r\n```\r\n\r\n下添加如下代码：\r\n\r\n```\r\nvar CommentModel = require('./comments');\r\n\r\n// 给 post 添加留言数 commentsCount\r\nPost.plugin('addCommentsCount', {\r\n  afterFind: function (posts) {\r\n    return Promise.all(posts.map(function (post) {\r\n      return CommentModel.getCommentsCount(post._id).then(function (commentsCount) {\r\n        post.commentsCount = commentsCount;\r\n        return post;\r\n      });\r\n    }));\r\n  },\r\n  afterFindOne: function (post) {\r\n    if (post) {\r\n      return CommentModel.getCommentsCount(post._id).then(function (count) {\r\n        post.commentsCount = count;\r\n        return post;\r\n      });\r\n    }\r\n    return post;\r\n  }\r\n});\r\n```\r\n\r\n在 PostModel 上注册了 `addCommentsCount` 用来给每篇文章添加留言数 `commentsCount`，在 `getPostById` 和 `getPosts` 方法里的：\r\n\r\n```\r\n.addCreatedAt()\r\n```\r\n\r\n下添加：\r\n\r\n```\r\n.addCommentsCount()\r\n```\r\n\r\n这样主页和文章页的文章就可以正常显示留言数了。\r\n\r\n然后将 `delPostById` 修改为：\r\n\r\n```\r\n// 通过用户 id 和文章 id 删除一篇文章\r\ndelPostById: function delPostById(postId, author) {\r\n  return Post.remove({ author: author, _id: postId })\r\n    .exec()\r\n    .then(function (res) {\r\n      // 文章删除后，再删除该文章下的所有留言\r\n      if (res.result.ok && res.result.n > 0) {\r\n        return CommentModel.delCommentsByPostId(postId);\r\n      }\r\n    });\r\n}\r\n```\r\n\r\n> 小提示：虽然目前看起来使用 Mongolass 自定义插件并不能节省代码，反而使代码变多了。Mongolass 插件真正的优势在于：在项目非常庞大时，可通过自定义的插件随意组合（及顺序）实现不同的输出，如上面的 `getPostById` 需要将取出 markdown 转换成 html，则使用 `.contentToHtml()`，否则像 `getRawPostById` 则不使用。\r\n\r\n修改 routes/posts.js，在：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\nvar PostModel = require('../models/posts');\r\n```\r\n\r\n下引入 CommentModel:\r\n\r\n```\r\nvar CommentModel = require('../models/comments');\r\n```\r\n\r\n在文章页传入留言列表，将：\r\n\r\n```\r\n// GET /posts/:postId 单独一篇的文章页\r\nrouter.get('/:postId', function(req, res, next) {\r\n  var postId = req.params.postId;\r\n\r\n  Promise.all([\r\n    PostModel.getPostById(postId),// 获取文章信息\r\n    PostModel.incPv(postId)// pv 加 1\r\n  ])\r\n  .then(function (result) {\r\n    var post = result[0];\r\n    if (!post) {\r\n      throw new Error('该文章不存在');\r\n    }\r\n\r\n    res.render('post', {\r\n      post: post\r\n    });\r\n  })\r\n  .catch(next);\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// GET /posts/:postId 单独一篇的文章页\r\nrouter.get('/:postId', function(req, res, next) {\r\n  var postId = req.params.postId;\r\n\r\n  Promise.all([\r\n    PostModel.getPostById(postId),// 获取文章信息\r\n    CommentModel.getComments(postId),// 获取该文章所有留言\r\n    PostModel.incPv(postId)// pv 加 1\r\n  ])\r\n  .then(function (result) {\r\n    var post = result[0];\r\n    var comments = result[1];\r\n    if (!post) {\r\n      throw new Error('该文章不存在');\r\n    }\r\n\r\n    res.render('post', {\r\n      post: post,\r\n      comments: comments\r\n    });\r\n  })\r\n  .catch(next);\r\n});\r\n```\r\n\r\n现在刷新文章页试试吧。\r\n\r\n## 4.10.3 发表与删除留言\r\n\r\n现在我们来实现发表与删除留言的功能。修改 routes/posts.js，将：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\n// POST /posts/:postId/comment 创建一条留言\r\nrouter.post('/:postId/comment', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId/comment/:commentId/remove 删除一条留言\r\nrouter.get('/:postId/comment/:commentId/remove', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// POST /posts/:postId/comment 创建一条留言\r\nrouter.post('/:postId/comment', checkLogin, function(req, res, next) {\r\n  var author = req.session.user._id;\r\n  var postId = req.params.postId;\r\n  var content = req.fields.content;\r\n  var comment = {\r\n    author: author,\r\n    postId: postId,\r\n    content: content\r\n  };\r\n\r\n  CommentModel.create(comment)\r\n    .then(function () {\r\n      req.flash('success', '留言成功');\r\n      // 留言成功后跳转到上一页\r\n      res.redirect('back');\r\n    })\r\n    .catch(next);\r\n});\r\n\r\n// GET /posts/:postId/comment/:commentId/remove 删除一条留言\r\nrouter.get('/:postId/comment/:commentId/remove', checkLogin, function(req, res, next) {\r\n  var commentId = req.params.commentId;\r\n  var author = req.session.user._id;\r\n\r\n  CommentModel.delCommentById(commentId, author)\r\n    .then(function () {\r\n      req.flash('success', '删除留言成功');\r\n      // 删除成功后跳转到上一页\r\n      res.redirect('back');\r\n    })\r\n    .catch(next);\r\n});\r\n```\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.10.1 留言模型设计\r\n\r\n我们只需要留言的作者 id、留言内容和关联的文章 id 这几个字段，修改 lib/mongo.js，添加如下代码：\r\n\r\nlib/mongo.js\r\n\r\n\r\nexp...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 20 */
    {
        "_id" : ObjectId("5881f77d58fad51b44c08d3b"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 20— 文章页面",
        "content" : "## 4.9.1 文章模型设计\r\n\r\n我们只存储文章的作者 id、标题、正文和点击量这几个字段，对应修改 lib/mongo.js，添加如下代码：\r\n\r\n**lib/mongo.js**\r\n\r\n```\r\nexports.Post = mongolass.model('Post', {\r\n  author: { type: Mongolass.Types.ObjectId },\r\n  title: { type: 'string' },\r\n  content: { type: 'string' },\r\n  pv: { type: 'number' }\r\n});\r\nexports.Post.index({ author: 1, _id: -1 }).exec();// 按创建时间降序查看用户的文章列表\r\n```\r\n\r\n## 4.9.2 发表文章\r\n\r\n现在我们来实现发表文章的功能。首先创建发表文章页，新建 views/create.ejs，添加如下代码：\r\n\r\n**views/create.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n\r\n<div class=\"ui grid\">\r\n  <div class=\"four wide column\">\r\n    <a class=\"avatar\"\r\n       href=\"/posts?author=<%= user._id %>\"\r\n       data-title=\"<%= user.name %> | <%= ({m: '男', f: '女', x: '保密'})[user.gender] %>\"\r\n       data-content=\"<%= user.bio %>\">\r\n      <img class=\"avatar\" src=/img/markdown_img/<%= user.avatar %>\">\r\n    </a>\r\n  </div>\r\n\r\n  <div class=\"eight wide column\">\r\n    <form class=\"ui form segment\" method=\"post\" action=\"/posts\">\r\n      <div class=\"field required\">\r\n        <label>标题</label>\r\n        <input type=\"text\" name=\"title\">\r\n      </div>\r\n      <div class=\"field required\">\r\n        <label>内容</label>\r\n        <textarea name=\"content\" rows=\"15\"></textarea>\r\n      </div>\r\n      <input type=\"submit\" class=\"ui button\" value=\"发布\">\r\n    </div>\r\n  </form>\r\n</div>\r\n\r\n<%- include('footer') %>\r\n```\r\n\r\n新建 models/posts.js 用来存放与文章操作相关的代码：\r\n\r\n**models/posts.js**\r\n\r\n```\r\nvar Post = require('../lib/mongo').Post;\r\n\r\nmodule.exports = {\r\n  // 创建一篇文章\r\n  create: function create(post) {\r\n    return Post.create(post).exec();\r\n  }\r\n};\r\n```\r\n\r\n修改 routes/posts.js，在文件上方引入 PostModel：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\nvar PostModel = require('../models/posts');\r\n```\r\n\r\n将：\r\n\r\n```\r\n// GET /posts/create 发表文章页\r\nrouter.get('/create', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /posts 发表一篇文章\r\nrouter.post('/', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// GET /posts/create 发表文章页\r\nrouter.get('/create', checkLogin, function(req, res, next) {\r\n  res.render('create');\r\n});\r\n\r\n// POST /posts 发表一篇文章\r\nrouter.post('/', checkLogin, function(req, res, next) {\r\n  var author = req.session.user._id;\r\n  var title = req.fields.title;\r\n  var content = req.fields.content;\r\n\r\n  // 校验参数\r\n  try {\r\n    if (!title.length) {\r\n      throw new Error('请填写标题');\r\n    }\r\n    if (!content.length) {\r\n      throw new Error('请填写内容');\r\n    }\r\n  } catch (e) {\r\n    req.flash('error', e.message);\r\n    return res.redirect('back');\r\n  }\r\n\r\n  var post = {\r\n    author: author,\r\n    title: title,\r\n    content: content,\r\n    pv: 0\r\n  };\r\n\r\n  PostModel.create(post)\r\n    .then(function (result) {\r\n      // 此 post 是插入 mongodb 后的值，包含 _id\r\n      post = result.ops[0];\r\n      req.flash('success', '发表成功');\r\n      // 发表成功后跳转到该文章页\r\n      res.redirect(`/posts/${post._id}`);\r\n    })\r\n    .catch(next);\r\n});\r\n```\r\n\r\n现在访问 `localhost:3000/posts/create` 发表篇文章试试吧，发表成功后跳转到了文章页但并没有任何内容，下面我们就来实现文章页及主页。\r\n\r\n## 4.9.3 主页与文章页\r\n\r\n现在我们来实现主页及文章页。修改 models/posts.js 如下：\r\n\r\n**models/posts.js**\r\n\r\n```\r\nvar marked = require('marked');\r\nvar Post = require('../lib/mongo').Post;\r\n\r\n// 将 post 的 content 从 markdown 转换成 html\r\nPost.plugin('contentToHtml', {\r\n  afterFind: function (posts) {\r\n    return posts.map(function (post) {\r\n      post.content = marked(post.content);\r\n      return post;\r\n    });\r\n  },\r\n  afterFindOne: function (post) {\r\n    if (post) {\r\n      post.content = marked(post.content);\r\n    }\r\n    return post;\r\n  }\r\n});\r\n\r\nmodule.exports = {\r\n  // 创建一篇文章\r\n  create: function create(post) {\r\n    return Post.create(post).exec();\r\n  },\r\n\r\n  // 通过文章 id 获取一篇文章\r\n  getPostById: function getPostById(postId) {\r\n    return Post\r\n      .findOne({ _id: postId })\r\n      .populate({ path: 'author', model: 'User' })\r\n      .addCreatedAt()\r\n      .contentToHtml()\r\n      .exec();\r\n  },\r\n\r\n  // 按创建时间降序获取所有用户文章或者某个特定用户的所有文章\r\n  getPosts: function getPosts(author) {\r\n    var query = {};\r\n    if (author) {\r\n      query.author = author;\r\n    }\r\n    return Post\r\n      .find(query)\r\n      .populate({ path: 'author', model: 'User' })\r\n      .sort({ _id: -1 })\r\n      .addCreatedAt()\r\n      .contentToHtml()\r\n      .exec();\r\n  },\r\n\r\n  // 通过文章 id 给 pv 加 1\r\n  incPv: function incPv(postId) {\r\n    return Post\r\n      .update({ _id: postId }, { $inc: { pv: 1 } })\r\n      .exec();\r\n  }\r\n};\r\n```\r\n\r\n需要讲解两点：\r\n\r\n1. 我们使用了 markdown 解析文章的内容，所以在发表文章的时候可使用 markdown 语法（如插入链接、图片等等），关于 markdown 的使用请参考： [Markdown 语法说明](http://wowubuntu.com/markdown/)。\r\n2. 我们在 PostModel 上注册了 `contentToHtml`，而 `addCreatedAt` 是在 lib/mongo.js 中 mongolass 上注册的。\r\n\r\n接下来完成主页的模板，修改 views/posts.ejs 如下：\r\n\r\n**views/posts.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n\r\n<% posts.forEach(function (post) { %>\r\n  <%- include('components/post-content', { post: post }) %>\r\n<% }) %>\r\n\r\n<%- include('footer') %>\r\n```\r\n\r\n新建 views/components/post-content.ejs 用来存放单篇文章的模板片段：\r\n\r\n**views/components/post-content.ejs**\r\n\r\n```\r\n<div class=\"post-content\">\r\n  <div class=\"ui grid\">\r\n    <div class=\"four wide column\">\r\n      <a class=\"avatar\"\r\n         href=\"/posts?author=<%= post.author._id %>\"\r\n         data-title=\"<%= post.author.name %> | <%= ({m: '男', f: '女', x: '保密'})[post.author.gender] %>\"\r\n         data-content=\"<%= post.author.bio %>\">\r\n        <img class=\"avatar\" src=/img/markdown_img/<%= post.author.avatar %>\">\r\n      </a>\r\n    </div>\r\n\r\n    <div class=\"eight wide column\">\r\n      <div class=\"ui segment\">\r\n        <h3><a href=\"/posts/<%= post._id %>\"><%= post.title %></a></h3>\r\n        <pre><%- post.content %></pre>\r\n        <div>\r\n          <span class=\"tag\"><%= post.created_at %></span>\r\n          <span class=\"tag right\">\r\n            <span>浏览(<%= post.pv %>)</span>\r\n            <span>留言(<%= post.commentsCount %>)</span>\r\n\r\n            <% if (user && post.author._id && user._id.toString() === post.author._id.toString()) { %>\r\n              <div class=\"ui inline dropdown\">\r\n                <div class=\"text\"></div>\r\n                <i class=\"dropdown icon\"></i>\r\n                <div class=\"menu\">\r\n                  <div class=\"item\"><a href=\"/posts/<%= post._id %>/edit\">编辑</a></div>\r\n                  <div class=\"item\"><a href=\"/posts/<%= post._id %>/remove\">删除</a></div>\r\n                </div>\r\n              </div>\r\n            <% } %>\r\n\r\n          </span>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n> 注意：我们用了 `<%- post.content %>`，而不是 `<%= post.content %>`，因为 post.content 是 markdown 转换成的 html 字符串。\r\n\r\n修改 routes/posts.js，将：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\nrouter.get('/', function(req, res, next) {\r\n  res.render('posts');\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\nrouter.get('/', function(req, res, next) {\r\n  var author = req.query.author;\r\n\r\n  PostModel.getPosts(author)\r\n    .then(function (posts) {\r\n      res.render('posts', {\r\n        posts: posts\r\n      });\r\n    })\r\n    .catch(next);\r\n});\r\n```\r\n\r\n> 注意：主页与用户页通过 url 中的 author 区分。\r\n\r\n现在完成了主页与用户页，访问 `http://localhost:3000/posts` 试试吧，尝试点击用户的头像看看效果。\r\n\r\n接下来完成文章页。新建 views/post.ejs，添加如下代码：\r\n\r\n**views/post.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n<%- include('components/post-content') %>\r\n<%- include('footer') %>\r\n```\r\n\r\n打开 routes/posts.js，将：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\n// GET /posts/:postId 单独一篇的文章页\r\nrouter.get('/:postId', function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// GET /posts/:postId 单独一篇的文章页\r\nrouter.get('/:postId', function(req, res, next) {\r\n  var postId = req.params.postId;\r\n\r\n  Promise.all([\r\n    PostModel.getPostById(postId),// 获取文章信息\r\n    PostModel.incPv(postId)// pv 加 1\r\n  ])\r\n  .then(function (result) {\r\n    var post = result[0];\r\n    if (!post) {\r\n      throw new Error('该文章不存在');\r\n    }\r\n\r\n    res.render('post', {\r\n      post: post\r\n    });\r\n  })\r\n  .catch(next);\r\n});\r\n```\r\n\r\n现在刷新浏览器，点击文章的标题看看浏览器地址的变化吧。\r\n\r\n## 4.9.4 编辑与删除文章\r\n\r\n现在我们来完成编辑与删除文章的功能。修改 models/posts.js，在 module.exports 对象上添加如下 3 个方法：\r\n\r\n**models/posts.js**\r\n\r\n```\r\n// 通过文章 id 获取一篇原生文章（编辑文章）\r\ngetRawPostById: function getRawPostById(postId) {\r\n  return Post\r\n    .findOne({ _id: postId })\r\n    .populate({ path: 'author', model: 'User' })\r\n    .exec();\r\n},\r\n\r\n// 通过用户 id 和文章 id 更新一篇文章\r\nupdatePostById: function updatePostById(postId, author, data) {\r\n  return Post.update({ author: author, _id: postId }, { $set: data }).exec();\r\n},\r\n\r\n// 通过用户 id 和文章 id 删除一篇文章\r\ndelPostById: function delPostById(postId, author) {\r\n  return Post.remove({ author: author, _id: postId }).exec();\r\n}\r\n```\r\n\r\n> 注意：不要忘了在适当位置添加逗号，如 incPv 的结束大括号后。\r\n\r\n> 注意：我们通过新函数 `getRawPostById` 用来获取文章原生的内容，而不是用 `getPostById` 返回将 markdown 转换成 html 后的内容。\r\n\r\n新建编辑文章页 views/edit.ejs，添加如下代码：\r\n\r\n**views/edit.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n\r\n<div class=\"ui grid\">\r\n  <div class=\"four wide column\">\r\n    <a class=\"avatar\"\r\n       href=\"/posts?author=<%= user._id %>\"\r\n       data-title=\"<%= user.name %> | <%= ({m: '男', f: '女', x: '保密'})[user.gender] %>\"\r\n       data-content=\"<%= user.bio %>\">\r\n      <img class=\"avatar\" src=/img/markdown_img/<%= user.avatar %>\">\r\n    </a>\r\n  </div>\r\n\r\n  <div class=\"eight wide column\">\r\n    <form class=\"ui form segment\" method=\"post\" action=\"/posts/<%= post._id %>/edit\">\r\n      <div class=\"field required\">\r\n        <label>标题</label>\r\n        <input type=\"text\" name=\"title\" value=\"<%= post.title %>\">\r\n      </div>\r\n      <div class=\"field required\">\r\n        <label>内容</label>\r\n        <textarea name=\"content\" rows=\"15\"><%= post.content %></textarea>\r\n      </div>\r\n      <input type=\"submit\" class=\"ui button\" value=\"发布\">\r\n    </div>\r\n  </form>\r\n</div>\r\n\r\n<%- include('footer') %>\r\n```\r\n\r\n修改 routes/posts.js，将：\r\n\r\n**routes/posts.js**\r\n\r\n```\r\n// GET /posts/:postId/edit 更新文章页\r\nrouter.get('/:postId/edit', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /posts/:postId/edit 更新一篇文章\r\nrouter.post('/:postId/edit', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId/remove 删除一篇文章\r\nrouter.get('/:postId/remove', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n```\r\n\r\n修改为：\r\n\r\n```\r\n// GET /posts/:postId/edit 更新文章页\r\nrouter.get('/:postId/edit', checkLogin, function(req, res, next) {\r\n  var postId = req.params.postId;\r\n  var author = req.session.user._id;\r\n\r\n  PostModel.getRawPostById(postId)\r\n    .then(function (post) {\r\n      if (!post) {\r\n        throw new Error('该文章不存在');\r\n      }\r\n      if (author.toString() !== post.author._id.toString()) {\r\n        throw new Error('权限不足');\r\n      }\r\n      res.render('edit', {\r\n        post: post\r\n      });\r\n    })\r\n    .catch(next);\r\n});\r\n\r\n// POST /posts/:postId/edit 更新一篇文章\r\nrouter.post('/:postId/edit', checkLogin, function(req, res, next) {\r\n  var postId = req.params.postId;\r\n  var author = req.session.user._id;\r\n  var title = req.fields.title;\r\n  var content = req.fields.content;\r\n\r\n  PostModel.updatePostById(postId, author, { title: title, content: content })\r\n    .then(function () {\r\n      req.flash('success', '编辑文章成功');\r\n      // 编辑成功后跳转到上一页\r\n      res.redirect(`/posts/${postId}`);\r\n    })\r\n    .catch(next);\r\n});\r\n\r\n// GET /posts/:postId/remove 删除一篇文章\r\nrouter.get('/:postId/remove', checkLogin, function(req, res, next) {\r\n  var postId = req.params.postId;\r\n  var author = req.session.user._id;\r\n\r\n  PostModel.delPostById(postId, author)\r\n    .then(function () {\r\n      req.flash('success', '删除文章成功');\r\n      // 删除成功后跳转到主页\r\n      res.redirect('/posts');\r\n    })\r\n    .catch(next);\r\n});\r\n```\r\n\r\n现在刷新主页，点击文章右下角的小三角，编辑文章和删除文章试试吧。\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.9.1 文章模型设计\r\n\r\n我们只存储文章的作者 id、标题、正文和点击量这几个字段，对应修改 lib/mongo.js，添加如下代码：\r\n\r\nlib/mongo.js\r\n\r\n\r\nexports...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 2
    },

    /* 21 */
    {
        "_id" : ObjectId("5881f7a55c1f2c243cd12bfb"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 19— 登陆与退出页面",
        "content" : "## 4.8.1 登出\r\n\r\n现在我们来完成登出的功能。修改 routes/signout.js 如下：\r\n\r\n**routes/signout.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar checkLogin = require('../middlewares/check').checkLogin;\r\n\r\n// GET /signout 登出\r\nrouter.get('/', checkLogin, function(req, res, next) {\r\n  // 清空 session 中用户信息\r\n  req.session.user = null;\r\n  req.flash('success', '登出成功');\r\n  // 登出成功后跳转到主页\r\n  res.redirect('/posts');\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n此时点击右上角的 `登出`，成功后如下图所示：\r\n\r\n![](/img/markdown_img/4.8.1.png)\r\n\r\n## 4.8.2 登录页\r\n\r\n现在我们来完成登录页。修改 routes/signin.js 相应代码如下：\r\n\r\n**routes/signin.js**\r\n\r\n```\r\nrouter.get('/', checkNotLogin, function(req, res, next) {\r\n  res.render('signin');\r\n});\r\n```\r\n\r\n新建 views/signin.ejs，添加如下代码：\r\n\r\n**views/signin.ejs**\r\n\r\n```\r\n<%- include('header') %>\r\n\r\n<div class=\"ui grid\">\r\n  <div class=\"four wide column\"></div>\r\n  <div class=\"eight wide column\">\r\n    <form class=\"ui form segment\" method=\"post\">\r\n      <div class=\"field required\">\r\n        <label>用户名</label>\r\n        <input placeholder=\"用户名\" type=\"text\" name=\"name\">\r\n      </div>\r\n      <div class=\"field required\">\r\n        <label>密码</label>\r\n        <input placeholder=\"密码\" type=\"password\" name=\"password\">\r\n      </div>\r\n      <input type=\"submit\" class=\"ui button fluid\" value=\"登录\">\r\n    </div>\r\n  </form>\r\n</div>\r\n\r\n<%- include('footer') %>\r\n```\r\n\r\n现在访问 `localhost:3000/signin` 试试吧。\r\n\r\n## 4.8.3 登录\r\n\r\n现在我们来完成登录的功能。修改 models/users.js 添加 `getUserByName` 方法用于通过用户名获取用户信息：\r\n\r\n**models/users.js**\r\n\r\n```\r\nvar User = require('../lib/mongo').User;\r\n\r\nmodule.exports = {\r\n  // 注册一个用户\r\n  create: function create(user) {\r\n    return User.create(user).exec();\r\n  },\r\n\r\n  // 通过用户名获取用户信息\r\n  getUserByName: function getUserByName(name) {\r\n    return User\r\n      .findOne({ name: name })\r\n      .addCreatedAt()\r\n      .exec();\r\n  }\r\n};\r\n```\r\n\r\n这里我们使用了 `addCreatedAt` 自定义插件（通过 _id 生成时间戳），修改 lib/mongo.js，添加如下代码：\r\n\r\n**lib/mongo.js**\r\n\r\n```\r\nvar moment = require('moment');\r\nvar objectIdToTimestamp = require('objectid-to-timestamp');\r\n\r\n// 根据 id 生成创建时间 created_at\r\nmongolass.plugin('addCreatedAt', {\r\n  afterFind: function (results) {\r\n    results.forEach(function (item) {\r\n      item.created_at = moment(objectIdToTimestamp(item._id)).format('YYYY-MM-DD HH:mm');\r\n    });\r\n    return results;\r\n  },\r\n  afterFindOne: function (result) {\r\n    if (result) {\r\n      result.created_at = moment(objectIdToTimestamp(result._id)).format('YYYY-MM-DD HH:mm');\r\n    }\r\n    return result;\r\n  }\r\n});\r\n```\r\n\r\n> 小提示：24 位长的 ObjectId 前 4 个字节是精确到秒的时间戳，所以我们没有额外的存创建时间（如: createdAt）的字段。ObjectId 生成规则：\r\n\r\n![](/img/markdown_img/4.8.2.png)\r\n\r\n\r\n修改 routes/signin.js 如下：\r\n\r\n**routes/signin.js**\r\n\r\n```\r\nvar sha1 = require('sha1');\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar UserModel = require('../models/users');\r\nvar checkNotLogin = require('../middlewares/check').checkNotLogin;\r\n\r\n// GET /signin 登录页\r\nrouter.get('/', checkNotLogin, function(req, res, next) {\r\n  res.render('signin');\r\n});\r\n\r\n// POST /signin 用户登录\r\nrouter.post('/', checkNotLogin, function(req, res, next) {\r\n  var name = req.fields.name;\r\n  var password = req.fields.password;\r\n\r\n  UserModel.getUserByName(name)\r\n    .then(function (user) {\r\n      if (!user) {\r\n        req.flash('error', '用户不存在');\r\n        return res.redirect('back');\r\n      }\r\n      // 检查密码是否匹配\r\n      if (sha1(password) !== user.password) {\r\n        req.flash('error', '用户名或密码错误');\r\n        return res.redirect('back');\r\n      }\r\n      req.flash('success', '登录成功');\r\n      // 用户信息写入 session\r\n      delete user.password;\r\n      req.session.user = user;\r\n      // 跳转到主页\r\n      res.redirect('/posts');\r\n    })\r\n    .catch(next);\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n现在访问 `localhost:3000/signin`，用刚才注册的账号登录，如下图所示：\r\n\r\n![](/img/markdown_img/4.8.3.png)\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.8.1 登出\r\n\r\n现在我们来完成登出的功能。修改 routes/signout.js 如下：\r\n\r\nroutes/signout.js\r\n\r\n\r\nvar express = require('...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 1
    },

    /* 22 */
    {
        "_id" : ObjectId("5881f7cdc3991c155c1d53de"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 18— 数据库操作增、删、改、查",
        "content" : "我们使用 [Mongolass](https://github.com/mongolass/mongolass) 这个模块操作 mongodb 进行增删改查。在 myblog 下新建 lib 目录，在该目录下新建 mongo.js，添加如下代码：\r\n\r\n**lib/mongo.js**\r\n\r\n```\r\nvar config = require('config-lite');\r\nvar Mongolass = require('mongolass');\r\nvar mongolass = new Mongolass();\r\nmongolass.connect(config.mongodb);\r\n```\r\n\r\n## 4.6.1 为什么使用 Mongolass\r\n\r\n早期我使用官方的 [mongodb](https://www.npmjs.com/package/mongodb)（也叫 node-mongodb-native）库，后来也陆续尝试使用了许多其他 mongodb 的驱动库，[Mongoose](https://www.npmjs.com/package/mongoose) 是比较优秀的一个，使用 Mongoose 的时间也比较长。比较这两者，各有优缺点。\r\n\r\n#### node-mongodb-native:\r\n\r\n**优点：**\r\n\r\n1. 简单。参照文档即可上手，没有 Mongoose 的 Schema 那些对新手不友好的东西。\r\n2. 强大。毕竟是官方库，包含了所有且最新的 api，其他大部分的库都是在这个库的基础上改造的，包括 Mongoose。\r\n3. 文档健全。\r\n\r\n**缺点：**\r\n\r\n1.  起初只支持 callback，会写出以下这种代码：\r\n```\r\nmongodb.open(function (err, db) {\r\n  if (err) {\r\n    return callback(err);\r\n  }\r\n  db.collection('users', function (err, collection) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n    collection.find({ name: 'xxx' }, function (err, users) {\r\n      if (err) {\r\n        return callback(err);\r\n      }\r\n    })\r\n  ...\r\n```\r\n\r\n或者：\r\n\r\n```\r\nMongoClient.connect('mongodb://localhost:27017', function (err, mongodb) {\r\n  if (err) {\r\n    return callback(err);\r\n  }\r\n  mongodb.db('test').collection('users').find({ name: 'xxx' }, function (err, users) {\r\n    if (err) {\r\n      return callback(err);\r\n    }\r\n  })\r\n  ...\r\n```\r\n\r\n现在支持 Promise 了，和 co 一起使用好很多。\r\n2. 不支持文档校验。Mongoose 通过 Schema 支持文档校验，虽说 mongodb 是 no schema 的，但在生产环境中使用 Schema 有两点好处。一是对文档做校验，防止非正常情况下写入错误的数据到数据库，二是可以简化一些代码，如类型为 ObjectId 的字段查询或更新时可通过对应的字符串操作，不用每次包装成 ObjectId 对象。\r\n\r\n#### Mongoose:\r\n\r\n**优点：**\r\n\r\n1. 封装了数据库的操作，给人的感觉是同步的，其实内部是异步的。如 mongoose 与 MongoDB 建立连接：\r\n```\r\nvar mongoose = require('mongoose');\r\nmongoose.connect('mongodb://localhost/test');\r\nvar BlogModel = mongoose.model('Blog', { title: String, content: String });\r\nBlogModel.find()\r\n```\r\n2. 支持 Promise。这个也无需多说，Promise 是未来趋势，可结合 co 使用，也可结合 async/await 使用。\r\n3. 支持文档校验。如上所述。\r\n\r\n**缺点（个人观点）：**\r\n\r\n1. 功能多，复杂。Mongoose 很强大，有很多功能是比较鸡肋甚至可以去掉的，如果使用反而会影响代码的可读性。比如虚拟属性以及 schema 上定义 statics 方法和 instance 方法，可以把这些定义成外部方法，用到的时候调用即可。\r\n2. 较弱的 plugin 系统。如：`schema.pre('save', function(next) {})` 和 `schema.post('find', function(next) {})`，只支持异步 `next()`，灵活性大打折扣。\r\n3. 其他：对新手来说难以理解的 Schema、Model、Entry 之间的关系；容易混淆的 toJSON 和 toObject，以及有带有虚拟属性的情况；用和不用 exec 的情况以及直接用 then 的情况；返回的结果是 Mongoose 包装后的对象，在此对象上修改结果却无效等等。\r\n\r\n#### Mongolass\r\n\r\nMongolass 保持了与 mongodb 一样的 api，又借鉴了许多 Mongoose 的优点，同时又保持了精简。\r\n\r\n**优点：**\r\n\r\n1. 支持 Promise。\r\n2. 简单。参考 Mongolass 的 readme 即可上手，比 Mongoose 精简的多，本身代码也不多。\r\n3. 可选的 Schema。Mongolass 中的 Schema （基于 [another-json-schema](https://www.npmjs.com/package/another-json-schema)）是可选的，并且只用来做文档校验。如果定义了 schema 并关联到某个 model，则插入、更新和覆盖等操作都会校验文档是否满足 schema，同时 schema 也会尝试格式化该字段，类似于 Mongoose，如定义了一个字段为 ObjectId 类型，也可以用 ObjectId 的字符串无缝使用一样。如果没有 schema，则用法跟原生 mongodb 库一样。\r\n4. 简单却强大的插件系统。可以定义全局插件（对所有 model 生效），也可以定义某个 model 上的插件（只对该 model 生效）。Mongolass 插件的设计思路借鉴了中间件的概念（类似于 Koa），通过定义 `beforeXXX` 和 `afterXXX` （XXX为操作符首字母大写，如：`afterFind`）函数实现，函数返回 yieldable 的对象即可，所以每个插件内可以做一些其他的 IO 操作。不同的插件顺序会有不同的结果，而且每个插件的输入输出都是 plain object，而非 Mongolass 包装后的对象，没有虚拟属性，无需调用 toJSON 或 toObject。Mongolass 中的 `.populate()`就是一个内置的插件。\r\n5. 详细的错误信息。用过 Mongoose 的人一定遇到过这样的错：\r\n   `CastError: Cast to ObjectId failed for value \"xxx\" at path \"_id\"`\r\n   只知道一个期望是 ObjectId 的字段传入了非期望的值，通常很难定位出错的代码，即使定位到也得不到错误现场。得益于 [another-json-schema](https://www.npmjs.com/package/another-json-schema)，使用 Mongolass 在查询或者更新时，某个字段不匹配它定义的 schema 时（还没落到 mongodb）会给出详细的错误信息，如下所示：\r\n```\r\nconst Mongolass = require('mongolass');\r\nconst mongolass = new Mongolass('mongodb://localhost:27017/test');\r\n\r\nconst User = mongolass.model('User', {\r\n  name: { type: 'string' },\r\n  age: { type: 'number' }\r\n});\r\n\r\nUser\r\n  .insertOne({ name: 'nswbmw', age: 'wrong age' })\r\n  .exec()\r\n  .then(console.log)\r\n  .catch(function (e) {\r\n    console.error(e);\r\n    console.error(e.stack);\r\n  });\r\n/*\r\n{ [Error: ($.age: \"wrong age\") ? (type: number)]\r\n  validator: 'type',\r\n  actual: 'wrong age',\r\n  expected: { type: 'number' },\r\n  path: '$.age',\r\n  schema: 'UserSchema',\r\n  model: 'User',\r\n  plugin: 'MongolassSchema',\r\n  type: 'beforeInsertOne',\r\n  args: [] }\r\nError: ($.age: \"wrong age\") ? (type: number)\r\n    at throwError (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:215:17)\r\n    at validate (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:184:7)\r\n    at validateLeaf (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:175:12)\r\n    at iterator (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:120:14)\r\n    at iterator (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:133:29)\r\n    at _validateObject (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:108:11)\r\n    at _Schema.validate (/Users/nswbmw/Desktop/mongolass-demo/node_modules/another-json-schema/index.js:38:10)\r\n    at formatCreate (/Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/schema.js:183:25)\r\n    at Query.beforeInsertOne (/Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/schema.js:94:7)\r\n    at /Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/query.js:146:44\r\n    at next (native)\r\n    at onFulfilled (/Users/nswbmw/Desktop/mongolass-demo/node_modules/co/index.js:65:19)\r\n    at /Users/nswbmw/Desktop/mongolass-demo/node_modules/co/index.js:54:5\r\n    at co (/Users/nswbmw/Desktop/mongolass-demo/node_modules/co/index.js:50:10)\r\n    at Query.execBeforePlugins (/Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/query.js:142:10)\r\n    at /Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/query.js:67:39\r\n----- Mongolass error stack -----\r\nError\r\n    at Model.insertOne (/Users/nswbmw/Desktop/mongolass-demo/node_modules/mongolass/lib/query.js:108:16)\r\n    at Object.<anonymous> (/Users/nswbmw/Desktop/mongolass-demo/app.js:10:4)\r\n    at Module._compile (module.js:409:26)\r\n    at Object.Module._extensions..js (module.js:416:10)\r\n    at Module.load (module.js:343:32)\r\n    at Function.Module._load (module.js:300:12)\r\n    at Function.Module.runMain (module.js:441:10)\r\n    at startup (node.js:139:18)\r\n    at node.js:974:3\r\n */\r\n```\r\n可以看出，错误的原因是在 insertOne 一条用户数据到用户表的时候，age 期望是一个 number 类型的值，而我们传入的字符串 `wrong age`，然后从错误栈中可以快速定位到是 app.js 第 10 行代码抛出的错。\r\n\r\n**缺点：**\r\n\r\n1. schema 功能较弱，缺少如 required、default 功能。\r\n\r\n### 扩展阅读\r\n\r\n[从零开始写一个 Node.js 的 MongoDB 驱动库](https://zhuanlan.zhihu.com/p/24308524)\r\n",
        "category" : "xwzj",
        "postSummary" : "我们使用 Mongolass(https://github.com/mongolass/mongolass) 这个模块操作 mongodb 进行增删改查。在 myblog 下新建 lib 目录，在该目...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 3
    },

    /* 23 */
    {
        "_id" : ObjectId("5881f7ed8748852148791766"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 17— 页面设计",
        "content" : "我们使用 jQuery + Semantic-UI 实现前端页面的设计，最终效果图如下:\r\n\r\n**注册页**\r\n\r\n![](/img/markdown_img/4.5.1.png)\r\n\r\n**登录页**\r\n\r\n![](/img/markdown_img/4.5.2.png)\r\n\r\n**未登录时的主页（或用户页）**\r\n\r\n![](/img/markdown_img/4.5.3.png)\r\n\r\n**登录后的主页（或用户页）**\r\n\r\n![](/img/markdown_img/4.5.4.png)\r\n\r\n**发表文章页**\r\n\r\n![](/img/markdown_img/4.5.5.png)\r\n\r\n**编辑文章页**\r\n\r\n![](/img/markdown_img/4.5.6.png)\r\n\r\n**未登录时的文章页**\r\n\r\n![](/img/markdown_img/4.5.7.png)\r\n\r\n**登录后的文章页**\r\n\r\n![](/img/markdown_img/4.5.8.png)\r\n\r\n**通知**\r\n\r\n![](/img/markdown_img/4.5.9.png)\r\n![](/img/markdown_img/4.5.10.png)\r\n![](/img/markdown_img/4.5.11.png)\r\n\r\n## 4.5.1 组件\r\n\r\n前面提到过，我们可以将模板拆分成一些组件，然后使用 ejs 的 include 方法将组件组合起来进行渲染。我们将页面切分成以下组件：\r\n\r\n**主页**\r\n\r\n![](/img/markdown_img/4.5.12.png)\r\n\r\n**文章页**\r\n\r\n![](/img/markdown_img/4.5.13.png)\r\n\r\n根据上面的组件切分图，我们创建以下样式及模板文件：\r\n\r\n**public/css/style.css**\r\n\r\n```\r\n/* ---------- 全局样式 ---------- */\r\n\r\nbody {\r\n  width: 1100px;\r\n  height: 100%;\r\n  margin: 0 auto;\r\n  padding-top: 40px;\r\n}\r\n\r\na:hover {\r\n  border-bottom: 3px solid #4fc08d;\r\n}\r\n\r\n.button {\r\n  background-color: #4fc08d !important;\r\n  color: #fff !important;\r\n}\r\n\r\n.avatar {\r\n  border-radius: 3px;\r\n  width: 48px;\r\n  height: 48px;\r\n  float: right;\r\n}\r\n\r\n/* ---------- nav ---------- */\r\n\r\n.nav {\r\n  margin-bottom: 20px;\r\n  color: #999;\r\n  text-align: center;\r\n}\r\n\r\n.nav h1 {\r\n  color: #4fc08d;\r\n  display: inline-block;\r\n  margin: 10px 0;\r\n}\r\n\r\n/* ---------- nav-setting ---------- */\r\n\r\n.nav-setting {\r\n  position: fixed;\r\n  right: 30px;\r\n  top: 35px;\r\n  z-index: 999;\r\n}\r\n\r\n.nav-setting .ui.dropdown.button {\r\n  padding: 10px 10px 0 10px;\r\n  background-color: #fff !important;\r\n}\r\n\r\n.nav-setting .icon.bars {\r\n  color: #000;\r\n  font-size: 18px;\r\n}\r\n\r\n/* ---------- post-content ---------- */\r\n\r\n.post-content h3 a {\r\n  color: #4fc08d !important;\r\n}\r\n\r\n.post-content .tag {\r\n  font-size: 13px;\r\n  margin-right: 5px;\r\n  color: #999;\r\n}\r\n\r\n.post-content .tag.right {\r\n  float: right;\r\n  margin-right: 0;\r\n}\r\n\r\n.post-content .tag.right a {\r\n  color: #999;\r\n}\r\n```\r\n\r\n**views/header.ejs**\r\n\r\n```\r\n<!DOCTYPE html>\r\n<html>\r\n  <head>\r\n    <meta charset=\"utf-8\">\r\n    <title><%= blog.title %></title>\r\n    <link rel=\"stylesheet\" href=\"//cdn.bootcss.com/semantic-ui/2.1.8/semantic.min.css\">\r\n    <link rel=\"stylesheet\" href=\"/css/style.css\">\r\n    <script src=\"//cdn.bootcss.com/jquery/1.11.3/jquery.min.js\"></script>\r\n    <script src=\"//cdn.bootcss.com/semantic-ui/2.1.8/semantic.min.js\"></script>\r\n  </head>\r\n  <body>\r\n  <%- include('components/nav') %>\r\n  <%- include('components/nav-setting') %>\r\n  <%- include('components/notification') %>\r\n```\r\n\r\n**views/footer.ejs**\r\n\r\n```\r\n  <script type=\"text/javascript\">\r\n    // 点击按钮弹出下拉框\r\n    $('.ui.dropdown').dropdown();\r\n    // 鼠标悬浮在头像上，弹出气泡提示框\r\n    $('.post-content .avatar').popup({\r\n      inline: true,\r\n      position: 'bottom right',\r\n      lastResort: 'bottom right',\r\n    });\r\n  </script>\r\n  </body>\r\n</html>\r\n```\r\n\r\n> 注意：上面 `<script></script>` 是 semantic-ui 操控页面控件的代码，一定要放到 footer.ejs 的 `</body>` 的前面，因为只有页面加载完后才能通过 JQuery 获取 DOM 元素。\r\n\r\n在 views 目录下新建 components 目录用来存放组件，在该目录下创建以下文件：\r\n\r\n**views/components/nav.ejs**\r\n\r\n```\r\n<div class=\"nav\">\r\n  <div class=\"ui grid\">\r\n    <div class=\"four wide column\"></div>\r\n\r\n    <div class=\"eight wide column\">\r\n      <a href=\"/posts\"><h1><%= blog.title %></h1></a>\r\n      <p><%= blog.description %></p>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n**views/components/nav-setting.ejs**\r\n\r\n```\r\n<div class=\"nav-setting\">\r\n  <div class=\"ui buttons\">\r\n    <div class=\"ui floating dropdown button\">\r\n      <i class=\"icon bars\"></i>\r\n      <div class=\"menu\">\r\n        <% if (user) { %>\r\n          <a class=\"item\" href=\"/posts?author=<%= user._id %>\">个人主页</a>\r\n          <div class=\"divider\"></div>\r\n          <a class=\"item\" href=\"/posts/create\">发表文章</a>\r\n          <a class=\"item\" href=\"/signout\">登出</a>\r\n        <% } else { %>\r\n          <a class=\"item\" href=\"/signin\">登录</a>\r\n          <a class=\"item\" href=\"/signup\">注册</a>\r\n        <% } %>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</div>\r\n```\r\n\r\n**views/components/notification.ejs**\r\n\r\n```\r\n<div class=\"ui grid\">\r\n  <div class=\"four wide column\"></div>\r\n  <div class=\"eight wide column\">\r\n\r\n  <% if (success) { %>\r\n    <div class=\"ui success message\">\r\n      <p><%= success %></p>\r\n    </div>\r\n  <% } %>\r\n\r\n  <% if (error) { %>\r\n    <div class=\"ui error message\">\r\n      <p><%= error %></p>\r\n    </div>\r\n  <% } %>\r\n\r\n  </div>\r\n</div>\r\n```\r\n\r\n## 4.5.2 app.locals 和 res.locals\r\n\r\n上面的模板中我们用到了 blog、user、success、error 变量，我们将 blog 变量挂载到 `app.locals` 下，将 user、success、error 挂载到 `res.locals` 下。为什么要这么做呢？`app.locals` 和 `res.locals` 是什么？它们有什么区别？\r\n\r\nexpress 中有两个对象可用于模板的渲染：`app.locals` 和 `res.locals`。我们从 express 源码一探究竟：\r\n\r\n**express/lib/application.js**\r\n\r\n```\r\napp.render = function render(name, options, callback) {\r\n  ...\r\n  var opts = options;\r\n  var renderOptions = {};\r\n  ...\r\n  // merge app.locals\r\n  merge(renderOptions, this.locals);\r\n\r\n  // merge options._locals\r\n  if (opts._locals) {\r\n    merge(renderOptions, opts._locals);\r\n  }\r\n\r\n  // merge options\r\n  merge(renderOptions, opts);\r\n  ...\r\n  tryRender(view, renderOptions, done);\r\n};\r\n```\r\n\r\n**express/lib/response.js**\r\n\r\n```\r\nres.render = function render(view, options, callback) {\r\n  var app = this.req.app;\r\n  var opts = options || {};\r\n  ...\r\n  // merge res.locals\r\n  opts._locals = self.locals;\r\n  ...\r\n  // render\r\n  app.render(view, opts, done);\r\n};\r\n```\r\n\r\n可以看出：在调用 `res.render` 的时候，express 合并（merge）了 3 处的结果后传入要渲染的模板，优先级：`res.render` 传入的对象> `res.locals` 对象 > `app.locals` 对象，所以 `app.locals` 和 `res.locals` 几乎没有区别，都用来渲染模板，使用上的区别在于：`app.locals` 上通常挂载常量信息（如博客名、描述、作者信息），`res.locals` 上通常挂载变量信息，即每次请求可能的值都不一样（如请求者信息，`res.locals.user = req.session.user`）。\r\n\r\n修改 index.js，在 `routes(app);` 上一行添加如下代码：\r\n\r\n```\r\n// 设置模板全局常量\r\napp.locals.blog = {\r\n  title: pkg.name,\r\n  description: pkg.description\r\n};\r\n\r\n// 添加模板必需的三个变量\r\napp.use(function (req, res, next) {\r\n  res.locals.user = req.session.user;\r\n  res.locals.success = req.flash('success').toString();\r\n  res.locals.error = req.flash('error').toString();\r\n  next();\r\n});\r\n```\r\n\r\n这样在调用 `res.render` 的时候就不用传入这四个变量了，express 为我们自动 merge 并传入了模板，所以我们可以在模板中直接使用这四个变量。\r\n\r\n",
        "category" : "xwzj",
        "postSummary" : "我们使用 jQuery  SemanticUI 实现前端页面的设计，最终效果图如下:\r\n\r\n注册页\r\n\r\n(/img/markdownimg/4.5.1.png)\r\n\r\n登录页\r\n\r\n(/img/ma...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 3
    },

    /* 24 */
    {
        "_id" : ObjectId("5881f812259d362648147b9d"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 16— 功能与路由设计",
        "content" : "## 4.4.1 功能与路由设计\r\n\r\n在开发博客之前，我们首先需要明确博客要实现哪些功能。由于本教程面向初学者，所以只实现了博客最基本的功能，其余的功能（如归档、标签、分页等等）读者可自行实现。\r\n\r\n功能及路由设计如下：\r\n\r\n1. 注册\r\n    1. 注册页：`GET /signup`\r\n    2. 注册（包含上传头像）：`POST /signup`\r\n2. 登录\r\n    1. 登录页：`GET /signin`\r\n    2. 登录：`POST /signin`\r\n3. 登出：`GET /signout`\r\n4. 查看文章\r\n    1. 主页：`GET /posts`\r\n    2. 个人主页：`GET /posts?author=xxx`\r\n    3. 查看一篇文章（包含留言）：`GET /posts/:postId`\r\n5. 发表文章\r\n    1. 发表文章页：`GET /posts/create`\r\n    2. 发表文章：`POST /posts`\r\n6. 修改文章\r\n    1. 修改文章页：`GET /posts/:postId/edit`\r\n    2. 修改文章：`POST /posts/:postId/edit`\r\n7. 删除文章：`GET /posts/:postId/remove`\r\n8. 留言\r\n    1. 创建留言：`POST /posts/:postId/comment`\r\n    2. 删除留言：`GET /posts/:postId/comment/:commentId/remove`\r\n\r\n由于我们博客页面是后端渲染的，所以只通过简单的 `<a>(GET)` 和 `<form>(POST)` 与后端进行交互，如果使用 jQuery 或者其他前端框架（如 angular、vue、react 等等）可通过 Ajax 与后端交互，则 api 的设计应尽量遵循 restful 风格。\r\n\r\n#### restful\r\n\r\nrestful 是一种 api 的设计风格，提出了一组 api 的设计原则和约束条件。\r\n\r\n如上面删除文章的路由设计：\r\n\r\n```\r\nGET /posts/:postId/remove\r\n```\r\n\r\nrestful 风格的设计：\r\n\r\n```\r\nDELETE /post/:postId\r\n```\r\n\r\n可以看出，restful 风格的 api 更直观且优雅。\r\n\r\n更多阅读：\r\n\r\n1. http://www.ruanyifeng.com/blog/2011/09/restful\r\n2. http://www.ruanyifeng.com/blog/2014/05/restful_api.html\r\n3. http://developer.51cto.com/art/200908/141825.htm\r\n4. http://blog.jobbole.com/41233/\r\n\r\n## 4.4.2 会话\r\n\r\n由于 HTTP 协议是无状态的协议，所以服务端需要记录用户的状态时，就需要用某种机制来识别具体的用户，这个机制就是会话（Session）。关于 Session 的讲解网上有许多资料，这里不再赘述。参考：\r\n\r\n1. http://justsee.iteye.com/blog/1570652\r\n2. https://www.zhihu.com/question/19786827\r\n\r\n#### cookie 与 session 的区别\r\n\r\n1. cookie 存储在浏览器（有大小限制），session 存储在服务端（没有大小限制）\r\n2. 通常 session 的实现是基于 cookie 的，即 session id 存储于 cookie 中\r\n\r\n我们通过引入 express-session 中间件实现对会话的支持：\r\n\r\n```\r\napp.use(session(options))\r\n```\r\n\r\nsession 中间件会在 req 上添加 session 对象，即 req.session 初始值为 `{}`，当我们登录后设置 `req.session.user = 用户信息`，返回浏览器的头信息中会带上 `set-cookie` 将 session id 写到浏览器 cookie 中，那么该用户下次请求时，通过带上来的 cookie 中的 session id 我们就可以查找到该用户，并将用户信息保存到 `req.session.user`。\r\n\r\n## 4.4.3 页面通知\r\n\r\n我们还需要这样一个功能：当我们操作成功时需要显示一个成功的通知，如登录成功跳转到主页时，需要显示一个 `登陆成功` 的通知；当我们操作失败时需要显示一个失败的通知，如注册时用户名被占用了，需要显示一个 `用户名已占用` 的通知。通知只显示一次，刷新后消失，我们可以通过 connect-flash 中间件实现这个功能。\r\n\r\n[connect-flash](https://www.npmjs.com/package/connect-flash) 是基于 session 实现的，它的原理很简单：设置初始值 `req.session.flash={}`，通过 `req.flash(name, value)` 设置这个对象下的字段和值，通过 `req.flash(name)` 获取这个对象下的值，同时删除这个字段。\r\n\r\n#### express-session、connect-mongo 和 connect-flash 的区别与联系\r\n\r\n1. `express-session`: 会话（session）支持中间件\r\n2. `connect-mongo`: 将 session 存储于 mongodb，需结合 express-session 使用，我们也可以将 session 存储于 redis，如 [connect-redis](https://www.npmjs.com/package/connect-redis)\r\n3. `connect-flash`: 基于 session 实现的用于通知功能的中间件，需结合 express-session 使用\r\n\r\n## 4.4.4 权限控制\r\n\r\n不管是论坛还是博客网站，我们没有登录的话只能浏览，登陆后才能发帖或写文章，即使登录了你也不能修改或删除其他人的文章，这就是权限控制。我们也来给博客添加权限控制，如何实现页面的权限控制呢？我们可以把用户状态的检查封装成一个中间件，在每个需要权限控制的路由加载该中间件，即可实现页面的权限控制。在 myblog 下新建 middlewares 文件夹，在该目录下新建 check.js，添加如下代码：\r\n\r\n\r\n**middlewares/check.js**\r\n\r\n```\r\nmodule.exports = {\r\n  checkLogin: function checkLogin(req, res, next) {\r\n    if (!req.session.user) {\r\n      req.flash('error', '未登录'); \r\n      return res.redirect('/signin');\r\n    }\r\n    next();\r\n  },\r\n\r\n  checkNotLogin: function checkNotLogin(req, res, next) {\r\n    if (req.session.user) {\r\n      req.flash('error', '已登录'); \r\n      return res.redirect('back');//返回之前的页面\r\n    }\r\n    next();\r\n  }\r\n};\r\n```\r\n\r\n可以看出：\r\n\r\n1. `checkLogin`: 当用户信息（`req.session.user`）不存在，即认为用户没有登录，则跳转到登录页，同时显示 `未登录` 的通知，用于需要用户登录才能操作的页面及接口\r\n2. `checkNotLogin`: 当用户信息（`req.session.user`）存在，即认为用户已经登录，则跳转到之前的页面，同时显示 `已登录` 的通知，如登录、注册页面及登录、注册的接口\r\n\r\n最终我们创建以下路由文件：\r\n\r\n**routes/index.js**\r\n\r\n```\r\nmodule.exports = function (app) {\r\n  app.get('/', function (req, res) {\r\n    res.redirect('/posts');\r\n  });\r\n  app.use('/signup', require('./signup'));\r\n  app.use('/signin', require('./signin'));\r\n  app.use('/signout', require('./signout'));\r\n  app.use('/posts', require('./posts'));\r\n};\r\n```\r\n\r\n**routes/posts.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar checkLogin = require('../middlewares/check').checkLogin;\r\n\r\n// GET /posts 所有用户或者特定用户的文章页\r\n//   eg: GET /posts?author=xxx\r\nrouter.get('/', function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /posts 发表一篇文章\r\nrouter.post('/', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/create 发表文章页\r\nrouter.get('/create', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId 单独一篇的文章页\r\nrouter.get('/:postId', function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId/edit 更新文章页\r\nrouter.get('/:postId/edit', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /posts/:postId/edit 更新一篇文章\r\nrouter.post('/:postId/edit', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId/remove 删除一篇文章\r\nrouter.get('/:postId/remove', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /posts/:postId/comment 创建一条留言\r\nrouter.post('/:postId/comment', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// GET /posts/:postId/comment/:commentId/remove 删除一条留言\r\nrouter.get('/:postId/comment/:commentId/remove', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n**routes/signin.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar checkNotLogin = require('../middlewares/check').checkNotLogin;\r\n\r\n// GET /signin 登录页\r\nrouter.get('/', checkNotLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /signin 用户登录\r\nrouter.post('/', checkNotLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n**routes/signup.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar checkNotLogin = require('../middlewares/check').checkNotLogin;\r\n\r\n// GET /signup 注册页\r\nrouter.get('/', checkNotLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\n// POST /signup 用户注册\r\nrouter.post('/', checkNotLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n**routes/signout.js**\r\n\r\n```\r\nvar express = require('express');\r\nvar router = express.Router();\r\n\r\nvar checkLogin = require('../middlewares/check').checkLogin;\r\n\r\n// GET /signout 登出\r\nrouter.get('/', checkLogin, function(req, res, next) {\r\n  res.send(req.flash());\r\n});\r\n\r\nmodule.exports = router;\r\n```\r\n\r\n最后， 修改 index.js 如下：\r\n\r\n**index.js**\r\n\r\n```\r\nvar path = require('path');\r\nvar express = require('express');\r\nvar session = require('express-session');\r\nvar MongoStore = require('connect-mongo')(session);\r\nvar flash = require('connect-flash');\r\nvar config = require('config-lite');\r\nvar routes = require('./routes');\r\nvar pkg = require('./package');\r\n\r\nvar app = express();\r\n\r\n// 设置模板目录\r\napp.set('views', path.join(__dirname, 'views'));\r\n// 设置模板引擎为 ejs\r\napp.set('view engine', 'ejs');\r\n\r\n// 设置静态文件目录\r\napp.use(express.static(path.join(__dirname, 'public')));\r\n// session 中间件\r\napp.use(session({\r\n  name: config.session.key,// 设置 cookie 中保存 session id 的字段名称\r\n  secret: config.session.secret,// 通过设置 secret 来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改\r\n  cookie: {\r\n    maxAge: config.session.maxAge// 过期时间，过期后 cookie 中的 session id 自动删除\r\n  },\r\n  store: new MongoStore({// 将 session 存储到 mongodb\r\n    url: config.mongodb// mongodb 地址\r\n  })\r\n}));\r\n// flash 中间价，用来显示通知\r\napp.use(flash());\r\n\r\n// 路由\r\nroutes(app);\r\n\r\n// 监听端口，启动程序\r\napp.listen(config.port, function () {\r\n  console.log(`${pkg.name} listening on port ${config.port}`);\r\n});\r\n```\r\n\r\n> 注意：中间件的加载顺序很重要。如上面设置静态文件目录的中间件应该放到 routes(app) 之前加载，这样静态文件的请求就不会落到业务逻辑的路由里；flash 中间件应该放到 session 中间件之后加载，因为 flash 是基于 session 的。\r\n\r\n运行 `supervisor --harmony index` 启动博客，访问以下地址查看效果：\r\n\r\n1. http://localhost:3000/posts\r\n2. http://localhost:3000/signout\r\n3. http://localhost:3000/signup\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.4.1 功能与路由设计\r\n\r\n在开发博客之前，我们首先需要明确博客要实现哪些功能。由于本教程面向初学者，所以只实现了博客最基本的功能，其余的功能（如归档、标签、分页等等）读者可自行实现。\r\n\r\n...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : true,
        "pv" : 4
    },

    /* 25 */
    {
        "_id" : ObjectId("5881f9587bfff623b4c1f9fc"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 14— 准备工作",
        "content" : "## 4.2.1 目录结构\r\n\r\n我们停止 supervisor 并删除 myblog 目录从头来过。重新创建 myblog，运行 `npm init`，如下：\r\n\r\n![](/img/markdown_img/4.2.1.png)\r\n\r\n在 myblog 目录下创建以下目录及空文件（package.json 除外）：\r\n\r\n![](/img/markdown_img/4.2.2.png)\r\n\r\n对应文件及文件夹的用处：\r\n\r\n1. `models`: 存放操作数据库的文件\r\n2. `public`: 存放静态文件，如样式、图片等\r\n3. `routes`: 存放路由文件\r\n4. `views`: 存放模板文件\r\n5. `index.js`: 程序主文件\r\n6. `package.json`: 存储项目名、描述、作者、依赖等等信息\r\n\r\n> 小提示：不知读者发现了没有，我们遵循了 MVC（模型(model)－视图(view)－控制器(controller/route)） 的开发模式。\r\n\r\n## 4.2.2 安装依赖模块 \r\n\r\n运行以下命令安装所需模块：\r\n\r\n```\r\nnpm i config-lite connect-flash connect-mongo ejs express express-formidable express-session marked moment mongolass objectid-to-timestamp sha1 winston express-winston --save\r\n```\r\n\r\n对应模块的用处：\r\n\r\n1. `express`: web 框架\r\n2. `express-session`: session 中间件\r\n3. `connect-mongo`: 将 session 存储于 mongodb，结合 express-session 使用\r\n4. `connect-flash`: 页面通知提示的中间件，基于 session 实现\r\n5. `ejs`: 模板\r\n6. `express-formidable`: 接收表单及文件的上传中间件\r\n7. `config-lite`: 读取配置文件\r\n8. `marked`: markdown 解析\r\n9. `moment`: 时间格式化\r\n10. `mongolass`: mongodb 驱动\r\n11. `objectid-to-timestamp`: 根据 ObjectId 生成时间戳\r\n12. `sha1`: sha1 加密，用于密码加密\r\n13. `winston`: 日志\r\n14. `express-winston`: 基于 winston 的用于 express 的日志中间件\r\n\r\n后面会详细讲解这些模块的用处。\r\n",
        "category" : "xwzj",
        "postSummary" : " 4.2.1 目录结构\r\n\r\n我们停止 supervisor 并删除 myblog 目录从头来过。重新创建 myblog，运行 npm init，如下：\r\n\r\n(/img/markdownimg/4....",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : true,
        "pv" : 10
    },

    /* 26 */
    {
        "_id" : ObjectId("5881f99569ef0820fc859ae4"),
        "author" : "yujian666",
        "title" : "nodejs+express+artTemplate+mongodb博客系列 15— 配置文件",
        "content" : "不管是小项目还是大项目，将配置与代码分离是一个非常好的做法。我们通常将配置写到一个配置文件里，如 config.js 或 config.json ，并放到项目的根目录下。但通常我们都会有许多环境，如本地开发环境、测试环境和线上环境等，不同的环境的配置不同，我们不可能每次部署时都要去修改引用 config.test.js 或者 config.production.js。config-lite 模块正是你需要的。\r\n\r\n## 4.3.1 config-lite\r\n\r\n[config-lite](https://www.npmjs.com/package/config-lite) 是一个轻量的读取配置文件的模块。config-lite 会根据环境变量（`NODE_ENV`）的不同从当前执行进程目录下的 config 目录加载不同的配置文件。如果不设置 `NODE_ENV`，则读取默认的 default 配置文件，如果设置了 `NODE_ENV`，则会合并指定的配置文件和 default 配置文件作为配置，config-lite 支持 .js、.json、.node、.yml、.yaml 后缀的文件。\r\n\r\n如果程序以 `NODE_ENV=test node app` 启动，则通过 `require('config-lite')` 会依次降级查找 `config/test.js`、`config/test.json`、`config/test.node`、`config/test.yml`、`config/test.yaml` 并合并 default 配置; 如果程序以 `NODE_ENV=production node app` 启动，则通过 `require('config-lite')` 会依次降级查找 `config/production.js`、`config/production.json`、`config/production.node`、`config/production.yml`、`config/production.yaml` 并合并 default 配置。\r\n\r\n在 myblog 下新建 config 目录，在该目录下新建 default.js，添加如下代码：\r\n\r\n**config/default.js**\r\n\r\n```\r\nmodule.exports = {\r\n  port: 3000,\r\n  session: {\r\n    secret: 'myblog',\r\n    key: 'myblog',\r\n    maxAge: 2592000000\r\n  },\r\n  mongodb: 'mongodb://localhost:27017/myblog'\r\n};\r\n```\r\n\r\n配置释义：\r\n\r\n1. `port`: 程序启动要监听的端口号\r\n2. `session`: express-session 的配置信息，后面介绍\r\n3. `mongodb`: mongodb 的地址，`myblog` 为 db 名\r\n",
        "category" : "xwzj",
        "postSummary" : "不管是小项目还是大项目，将配置与代码分离是一个非常好的做法。我们通常将配置写到一个配置文件里，如 config.js 或 config.json ，并放到项目的根目录下。但通常我们都会有许多环境，如本...",
        "sub_category" : "nodejs",
        "img_url" : "",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 25
    },

    /* 27 */
    {
        "_id" : ObjectId("5882b43775e4860b280c7d9f"),
        "author" : "yujian666",
        "title" : "移动端HTML5<video>视频播放优化实践",
        "content" : "## 遇到的挑战\r\n\r\n移动端HTML5使用原生&lt;video&gt;标签播放视频，要做到两个基本原则，速度快和体验佳，先来分析一下这两个问题。\r\n\r\n### 下载速度\r\n\r\n以一个8s短视频为例，wifi环境下提供的高清视频达到1000kbps，文件大小大约1MB；非wifi环境下提供的低码率视频是500kbps左右，文件大小大约500KB；参考QzoneTouch多普勒测速，2g网络的平均速度是14KB/s，那么下载一个低码率视频耗时35s；那么要想流畅播放视频，就需要一个加载等待的过程，这个过程要有明确的反馈，不能让用户有“坏掉了”的感觉。\r\n\r\n#### 多普勒测速数据参考\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>#</th>\r\n<th>dns(s)</th>\r\n<th>conn(s)</th>\r\n<th>rtt(s)</th>\r\n<th>tran(kb/s)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>2g</td>\r\n<td>3.85785</td>\r\n<td>2.33482</td>\r\n<td>2.57478</td>\r\n<td>14.0374</td>\r\n</tr>\r\n<tr>\r\n<td>3g</td>\r\n<td>1.60643</td>\r\n<td>0.743109</td>\r\n<td>0.608047</td>\r\n<td>60.1967</td>\r\n</tr>\r\n<tr>\r\n<td>wifi</td>\r\n<td>0.986921</td>\r\n<td>0.550208</td>\r\n<td>0.444332</td>\r\n<td>70.8728</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n### 用户体验\r\n\r\n视频是否可以自动播放，是否能循环播放，是否能显示下载进度，播放的时候如何隐藏控制条，暂停的时候又能显示出来呢。这些问题看上去貌似简单，但是由于PC/iOS/Android这些不同平台、不同的浏览器内核、甚至相同内核的不同版本，所实现的&lt;video&gt;属性、方法和事件差异较大，解决兼容性问题又给开发造成了很大困扰。<span id=\"more-4608\"></span>\r\n\r\n## 分析原因\r\n\r\n### 事件差异\r\n\r\n下面是播放一个短视频，在不同平台触发事件和获取属性的差异表现。\r\n\r\n#### PC\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>#</th>\r\n<th>event</th>\r\n<th>readyState</th>\r\n<th>currentTime (s)</th>\r\n<th>buffered (s)</th>\r\n<th>duration (s)</th>\r\n<th>视频状态</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>1</td>\r\n<td>loadstart</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>suspend</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>play</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>waiting</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>durationchange</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>5.35</td>\r\n<td>7.91</td>\r\n<td>获取到视频长度</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>loadedmetadata</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>0.66</td>\r\n<td>7.91</td>\r\n<td>获取到元数据</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>loadeddata</td>\r\n<td>ENOUGHDATA</td>\r\n<td>0</td>\r\n<td>0.66</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>canplay</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0.66</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>playing</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0.66</td>\r\n<td>7.91</td>\r\n<td>开始播放</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>canplaythrough</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0.66</td>\r\n<td>7.91</td>\r\n<td>可以流畅播放</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.11</td>\r\n<td>3.68</td>\r\n<td>7.91</td>\r\n<td>持续下载</td>\r\n</tr>\r\n<tr>\r\n<td>12</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.14</td>\r\n<td>4.44</td>\r\n<td>7.91</td>\r\n<td>播放进度变化</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n<tr>\r\n<td>23</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>1.77</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>下载完毕</td>\r\n</tr>\r\n<tr>\r\n<td>24</td>\r\n<td>suspend</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>1.77</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>25</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>1.9</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>继续播放中</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n<tr>\r\n<td>48</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>7.7</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>49</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>50</td>\r\n<td>seeking</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>51</td>\r\n<td>waiting</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>52</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>53</td>\r\n<td>seeked</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>播放完毕进度回到起点</td>\r\n</tr>\r\n<tr>\r\n<td>54</td>\r\n<td>canplay</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>55</td>\r\n<td>playing</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>循环播放</td>\r\n</tr>\r\n<tr>\r\n<td>56</td>\r\n<td>canplaythrough</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>57</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.19</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n#### iOS\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>#</th>\r\n<th>event</th>\r\n<th>readyState</th>\r\n<th>currentTime (s)</th>\r\n<th>buffered (s)</th>\r\n<th>duration (s)</th>\r\n<th>视频状态</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>1</td>\r\n<td>loadstart</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>play</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>waiting</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>durationchange</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>7.91</td>\r\n<td>获取到视频长度</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>loadedmetadata</td>\r\n<td>METADATA</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>7.91</td>\r\n<td>获取到元数据</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>loadeddata</td>\r\n<td>ENOUGHDATA</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>canplay</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>canplaythrough</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>可以流畅播放</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>playing</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>开始播放</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>下载完毕</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>suspend</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>12</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.02</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>播放进度变化</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n<tr>\r\n<td>43</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>7.8</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>44</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>45</td>\r\n<td>seeked</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>播放完毕进度回到起点</td>\r\n</tr>\r\n<tr>\r\n<td>46</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.22</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>循环播放</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n#### Android\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>#</th>\r\n<th>event</th>\r\n<th>readyState</th>\r\n<th>currentTime (s)</th>\r\n<th>buffered (s)</th>\r\n<th>duration (s)</th>\r\n<th>视频状态</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>1</td>\r\n<td>loadstart</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>2</td>\r\n<td>play</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>3</td>\r\n<td>waiting</td>\r\n<td>NOTHING</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>-</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>4</td>\r\n<td>durationchange</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>5</td>\r\n<td>durationchange</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>获取到视频长度</td>\r\n</tr>\r\n<tr>\r\n<td>6</td>\r\n<td>loadedmetadata</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>获取到元数据</td>\r\n</tr>\r\n<tr>\r\n<td>7</td>\r\n<td>loadeddata</td>\r\n<td>ENOUGHDATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>8</td>\r\n<td>canplay</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>9</td>\r\n<td>canplaythrough</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>10</td>\r\n<td>playing</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>11</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>12</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>3.57</td>\r\n<td>7.91</td>\r\n<td>下载中</td>\r\n</tr>\r\n<tr>\r\n<td>13</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0.2</td>\r\n<td>6.89</td>\r\n<td>7.91</td>\r\n<td>开始播放</td>\r\n</tr>\r\n<tr>\r\n<td>14</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>下载完毕</td>\r\n</tr>\r\n<tr>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n<td>…</td>\r\n</tr>\r\n<tr>\r\n<td>49</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>7.79</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>50</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>7.87</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>51</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>52</td>\r\n<td>seeking</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>播放完毕进度回到起点</td>\r\n</tr>\r\n<tr>\r\n<td>53</td>\r\n<td>timeupdate</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>54</td>\r\n<td>seeked</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>循环播放失败卡住了</td>\r\n</tr>\r\n<tr>\r\n<td>55</td>\r\n<td>progress</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>56</td>\r\n<td>stalled</td>\r\n<td>ENOUGH_DATA</td>\r\n<td>0</td>\r\n<td>7.91</td>\r\n<td>7.91</td>\r\n<td>-</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n#### 一些常用且需要重点关注的&lt;video&gt;事件\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>event</th>\r\n<th>iOS</th>\r\n<th>Android</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>******************</td>\r\n<td>***********************************************</td>\r\n<td>***********************************************</td>\r\n</tr>\r\n<tr>\r\n<td>play</td>\r\n<td>只是要播放视频，响应的是video.play()方法，并不代表已经开始播放</td>\r\n<td>和iOS一样，仅是响应video.play()方法</td>\r\n</tr>\r\n<tr>\r\n<td>durationchange</td>\r\n<td>会执行一次，一定会获取到视频的duration</td>\r\n<td>可能会执行多次，只有最后一次才能获取到真实的duration，前面的duration都是0；但低版本Android可能获取到的duration是0或1；（本文提到的低版本Android大部分是4.1以下）</td>\r\n</tr>\r\n<tr>\r\n<td>canplay</td>\r\n<td>可以认为是视频元素没有问题，可以运行，没有更多含义了，基本用不上</td>\r\n<td>同iOS</td>\r\n</tr>\r\n<tr>\r\n<td>canplaythrough</td>\r\n<td>会有明确的缓冲，表示可以流畅播放了；</td>\r\n<td>没有什么用，视频仍然会卡住，数据可能还没有开始加载；</td>\r\n</tr>\r\n<tr>\r\n<td>playing</td>\r\n<td>明确表示播放开始了；</td>\r\n<td>依然没有用，视频可能并没有开始播放；</td>\r\n</tr>\r\n<tr>\r\n<td>progress</td>\r\n<td>有明确的下载，可以获取到当前的buffer，并且全部下载完毕后不在触发；</td>\r\n<td>不一定有明确的数据下载，并且全部下载完毕后依然继续触发；</td>\r\n</tr>\r\n<tr>\r\n<td>timeupdate</td>\r\n<td>会有明确的进度变化，可以获取到currentTime；</td>\r\n<td>进度不一定变化，currentTime可能总是0，但是第一次有currentTime变化的timeupdate事件一定代表了视频开始播放了；</td>\r\n</tr>\r\n<tr>\r\n<td>error</td>\r\n<td>iOS中会有明确的错误抛出；</td>\r\n<td>Android中某些浏览器会莫名其妙的抛出error；</td>\r\n</tr>\r\n<tr>\r\n<td>stalled</td>\r\n<td>网络状况不佳，导致视频下载中断；</td>\r\n<td>在没有play之前，也可能会抛出该事件。</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n### 属性差异\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>attributes</th>\r\n<th>iOS</th>\r\n<th>android</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>******************</td>\r\n<td>***********************************************</td>\r\n<td>***********************************************</td>\r\n</tr>\r\n<tr>\r\n<td>poster\r\n\r\n封面图片</td>\r\n<td>支持，但是加载速度明显比在&lt;img&gt;中要慢；</td>\r\n<td>不一定支持（浏览器厂商的实现标准不统一）；</td>\r\n</tr>\r\n<tr>\r\n<td>preload\r\n\r\n预加载</td>\r\n<td>iPhone不支持；</td>\r\n<td>可能支持；</td>\r\n</tr>\r\n<tr>\r\n<td>autoplay\r\n\r\n自动播放</td>\r\n<td>iPhone Safari中不支持，但在webview中可能被开启；iOS开发文档明确说明蜂窝网络下不允许autoplay；</td>\r\n<td>可能支持；</td>\r\n</tr>\r\n<tr>\r\n<td>loop\r\n\r\n循环播放</td>\r\n<td>支持</td>\r\n<td>可能支持；</td>\r\n</tr>\r\n<tr>\r\n<td>controls\r\n\r\n控制条</td>\r\n<td>支持，但是需要开始播放了才显示</td>\r\n<td>基本都支持显示或者不显示</td>\r\n</tr>\r\n<tr>\r\n<td>width和height</td>\r\n<td>一定给出明确的属性设置，切不能为0；</td>\r\n<td>如果不设置，仅仅通过CSS样式去控制视频大小，可能会导致标签失效。</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n### 其他怪异bug和不友好表现\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>iOS</th>\r\n<th>android</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>*********************************************************</td>\r\n<td>*********************************************************</td>\r\n</tr>\r\n<tr>\r\n<td>物理位置覆盖在&lt;video&gt;区域上的元素，click和touch等事件会失效，比如一个&lt;a&gt;链接如果覆盖在&lt;video&gt;上，那么点击后没有任何效果。</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>iOS8.0+中，单页面播放视频超过16个，再播放的视频全部MediaError解码异常无法播放。</td>\r\n<td>-</td>\r\n</tr>\r\n<tr>\r\n<td>iPhone的Safari会弹出一个全屏的播放器来播放视频，iPad则支持内联播放。iOS7+ 如果webview（比如微信）开启了`webview.allowsInlineMediaPlayback = YES;`，可以通过设置`webkit-playsinline`属性支持内联播放；</td>\r\n<td>支持内联播放，但某些厂商会用自己的播放器劫持原生的视频播放；</td>\r\n</tr>\r\n<tr>\r\n<td>下载视频时，会先发送一个2字节的请求来获取视频元数据（比如时长），然后再不断的发送分包续传（206）请求来下载视频，抓包显示请求数和请求量至少有一倍的冗余（x2），这个严重的bug在iOS8中有明显的修复，但是分包的206请求仍然会有冗余数据的下载，浪费了流量。</td>\r\n<td>比iOS的处理方式好，没有第一个2字节请求，没有流量损耗；</td>\r\n</tr>\r\n<tr>\r\n<td>-</td>\r\n<td>低版本Android（&lt;=4.0.4）中，&lt;video&gt;如果在有相对和决定定位的层中，可能会导致整个页面错位。</td>\r\n</tr>\r\n<tr>\r\n<td>-</td>\r\n<td>某些浏览器厂商会劫持&lt;video&gt;，用其“自己”的播放器来播放视频，“破坏”了产品本身的播放体验，那么只能case by case的解决了。</td>\r\n</tr>\r\n<tr>\r\n<td>加载视频时没有进度提示，视觉上看不出是播放完了还是卡住了；</td>\r\n<td>加载视频时，大都会显示一个自带的loading UI（菊花）。</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n## 最佳实践\r\n\r\n### 视频初始化\r\n\r\n如果将一个&lt;video&gt;直接显示在页面中，那么就会看到各种五花八门的播放器初始效果；\r\n\r\n[![700ca10a-5ffb-11e4-81d2-b11726e4ea38](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/700ca10a-5ffb-11e4-81d2-b11726e4ea38.jpg)](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/700ca10a-5ffb-11e4-81d2-b11726e4ea38.jpg)\r\n\r\n&nbsp;\r\n\r\n这显然不是一个好的视觉体验，那么通常的做法是制作一个模拟的视频播放视图，比如一个封面加一个播放按钮。\r\n\r\n而真实的&lt;video&gt;视频元素要隐藏起来，如何隐藏呢？最好不要用`{display: none}`或者`{width:0;height:0;}`的方式，因为这样视频元素会处于未激活的状态，给后续的处理带来麻烦。最佳的方式是将视频设置成1×1像素大小，放在视觉边缘的位置。\r\n\r\n[![d3f7fdec-5ffe-11e4-8904-f8dbe720ed84](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/d3f7fdec-5ffe-11e4-8904-f8dbe720ed84.jpg)](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/d3f7fdec-5ffe-11e4-8904-f8dbe720ed84.jpg)\r\n\r\n### 自动播放\r\n\r\nautoplay的支持依赖内核和网络状况，比如iPhone在蜂窝网络下明确禁用了autoplay；\r\n\r\n经过试验，在没有明确的用户操作的情况下，直接通过`video.play()`也是无法激活播放的；\r\n\r\n并且在产品设计上，自动播放也不是一个舒服的用户体验，所以产品设计上尽量避免使用自动播放。\r\n\r\n### 点击播放\r\n\r\n之前提到，视频最好通过1px大小隐藏起来，那么这时如何触发播放呢？\r\n\r\n经过试验，当在明确的用户操作（touch、click）时，通过这些用户行为事件的回调函数，用`video.play()`是可以触发视频播放的，那么能否在用户操作后，再去同步的创建和播放视频呢？答案是肯定的，这无疑是一个视频元素初始化的最佳实践，但是有些差异需要注意。\r\n\r\n#### iOS6+\r\n\r\n可以在用户的touch时间中动态创建并播放视频。\r\n\r\n#### iOS &lt; 6\r\n\r\n可以在用户的touch时间中动态创建视频，但不能播放；要再追加一个click事件来启动播放；也就是说，给伪造的视频播放按钮同时绑定tap和click事件，在tap的时候创建，在之后300毫秒的click中去播放。\r\n\r\n#### Android\r\n\r\n大部分高版本Android可以像iOS6+那样去处理，但是低版本的不行，必须要通过click事件去传递`video.play()`，为了保持兼容，最好是用帮tap和click两个事件来分别完成视频的初始化和播放。\r\n\r\n我们还发现，有些低版本Android中，无法通过`video.play()`来播放视频，必须有真实的用户点击视频元素才能播放；这种情况，有一个技巧就是在tap的时候初始化并放大视频覆盖在播放视图中，让300毫秒后的真实点击行为穿透点击在视频元素上来实现播放。\r\n\r\n### 循环播放\r\n\r\n如果视频需要循环播放，那么就增加`loop`属性，是否能循环播放就看浏览器是否支持了，因为还没有找到hack技巧来强制循环播放；\r\n\r\n即使，在不支持循环播放的Android中，通过监听`seeked`事件知道了播放进度到了终点或起点暂停了，此时也无法通过`video.play()`来让视频重新播放。\r\n\r\n### 监控下载进度\r\n\r\n如何获取视频时长和已经下载的时长？\r\n\r\n\r\nprogress事件表示视频在加载，但是它的触发频率和时机并不规律，最佳做法是通过一个定时器去实时获取end，当end &gt;= duration时，表示已经下载完毕，再终止定时器。\r\n\r\n### 全部下载后再播放\r\n\r\n假设播放短视频，如果网络不佳，会造成播放断断续续，在iOS中这种停顿还没有一个明确的等待提示，这不是一个好的体验，那么是否可以将视频全部下载完毕再播放呢？\r\n\r\n在iOS中，可以在视频刚开始下载的时候马上暂停，此时下载还将继续，可以做一个loading的菊花告知视频正在加载，然后等到视频全部下载完再开始播放。\r\n\r\n[![454dabb2-6014-11e4-9651-06136a5a7332](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/454dabb2-6014-11e4-9651-06136a5a7332.gif)](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/454dabb2-6014-11e4-9651-06136a5a7332.gif)\r\n\r\n### 缓冲播放——边下边播时，选择开始播放的最佳时间点\r\n\r\n当视频越来越长或者网络慢时，等待视频全部下载完再播放也不是好的体验，最好能边下边播，缓冲到流畅状态就开始播放，那什么时候播放才是最佳时间点呢？\r\n\r\n在iOS中，canplaythrough事件就是这个最佳时间点，它是通过动态计算缓冲量和下载速度得出的视频可以流畅播放的状态反馈。\r\n\r\n> canplaythrough event: The user agent estimates that if playback were to be started now, the media resource could be rendered at the current playback rate all the way to its end without having to stop for further buffering.\r\n\r\n&nbsp;\r\n\r\n[![8fd35acc-6016-11e4-8755-684ef2656ddf](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/8fd35acc-6016-11e4-8755-684ef2656ddf.gif)](http://cdn.xuanfengge.com/wp-content/uploads/2015/01/8fd35acc-6016-11e4-8755-684ef2656ddf.gif)\r\n\r\n注意：下载完再播放和缓冲播放只适用于iOS。\r\n\r\n### 统计播放时间和播放次数\r\n\r\n要统计实际的播放时间，要累加timeupdate事件变化的时间，再减去中间可能暂停的时间。\r\n\r\n### 异常处理\r\n\r\n对error事件做详细的上报；\r\n\r\n对stalled事件做统计上报，并提示用户网络慢等。\r\n\r\n## 参考数据\r\n\r\n微视触屏版iOS视频测速\r\n\r\n<div class=\"table\"><table>\r\n<thead>\r\n<tr>\r\n<th>网络环境</th>\r\n<th>视频码率</th>\r\n<th>获取到视频时长\r\n\r\n时间点(s)</th>\r\n<th>开始流畅播放\r\n\r\n时间点(s)</th>\r\n<th>全部下载完毕\r\n\r\n时间点(s)</th>\r\n<th>视频长度(s)</th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>wifi</td>\r\n<td>1000kbps</td>\r\n<td>2.86</td>\r\n<td>3.97</td>\r\n<td>5.85</td>\r\n<td>8.69</td>\r\n</tr>\r\n<tr>\r\n<td>非wifi</td>\r\n<td>500kbps</td>\r\n<td>4.56</td>\r\n<td>8</td>\r\n<td>10.62</td>\r\n<td>8.67</td>\r\n</tr>\r\n</tbody>\r\n</table></div>\r\n\r\n## 参考资料\r\n\r\n*   HTML5 Video Events and API检测工具 [http://www.w3.org/2010/05/video/mediaevents.html](http://www.w3.org/2010/05/video/mediaevents.html)\r\n*   W3C video 标准 [http://www.w3.org/TR/html5/embedded-content-0.html#the-video-element](http://www.w3.org/TR/html5/embedded-content-0.html#the-video-element)\r\n*   如何在iOS7+的webview中内联播放视频 [http://darktalker.com/2014/play-video-inline-iphone-ios7](http://darktalker.com/2014/play-video-inline-iphone-ios7)\r\n*   视频事件流水查看工具 [http://z.weishi.qq.com/app/video.html](http://z.weishi.qq.com/app/video.html)",
        "category" : "xwzj",
        "postSummary" : " 遇到的挑战\r\n\r\n移动端HTML5使用原生&lt;video&gt;标签播放视频，要做到两个基本原则，速度快和体验佳，先来分析一下这两个问题。\r\n\r\n 下载速度\r\n\r\n以一个8s短视频为例，wifi...",
        "sub_category" : "html5",
        "img_url" : "",
        "tag" : "video;h5;播放器;",
        "recommend" : true,
        "pv" : 3
    },

    /* 28 */
    {
        "_id" : ObjectId("5882bbd7a493db21f89ff954"),
        "author" : "yujian666",
        "title" : "我是怎样用为知笔记的-01",
        "content" : "# 一、我的使用历程\r\n\r\n最早开始使用笔记软件是在2008年初。有天，我因为无聊，打开了Office 2007的安装目录，其中发现一个我很少用的程序：Onenote。好奇心导致我打开了它，简单明了的指导性说明引导我很快就掌握了它的使用方法。于是我首先使用了笔记软件的**资料收集整理功能**。\r\n\r\n后来，有个问题开始困扰着我：有一天，我重装电脑的时候，忘记备份了，Onenote中全部资料都消失掉了。于是我开始探索Onenote的备份功能，之后才发现，原来是可以备份到skydrive上面的，不过我很不喜欢它的界面，于是我就想找一款**能够备份、能够有树状目录、能够在不同平台见同步的笔记软件**。\r\n\r\n2010年初，我开始使用Evernote，就是国内现在的这款叫做印象笔记的软件。同时，我的为了工具而工具的这种恶习让我开始尝试着盛大的麦库和当时的Wiz，也就是后来的为知笔记，对了，我甚至还用过有道笔记！本来我大量的时间都放在evernote上的，后来发现了问题：**Evernote只是支持2层文件夹！**这根本就不够用嘛！！\r\n\r\n当时麦库还不成熟，很多bug，而有道笔记，我就莫名其妙的不喜欢，连点基本功能都没有。而Wiz，提供了可以支持将Evernote的资料无缝导入的功能，没得说，我就选了Wiz，那是2010年12月份的事了。\r\n\r\n到了去年年底，善用佳软上发了一篇名叫《[从Evernote叛逃到Wiz](http://xbeta.info/evernote2wiz.htm)》，我看了之后更加坚定了我的信心，我就用为知了！\r\n\r\n# 二、我用为知笔记干什么？\r\n\r\n记得以前教Photoshop课程，很多人知道如何操作ps，但是如果让他创作的话，他就会打开一幅空白的文档不知所措，因为他没有美工、绘画等其他基础知识。笔记这种形式已经存在多年了，由于很多人并<span id=\"0KSFindDIV\" class=\"KSFIND_CLASS_SELECT\">不</span>掌握记笔记的理念，也不知道如何记笔记，所以，在笔记数字化之后的产物：笔记软件纷纷出现的时候，很多人也是因为同样的原因，并不去使用笔记软件。\r\n\r\n一款软件的使用（下载、安装、操作）还是很简单的，再难的软件只要坚持看产品帮助，也都会使用的。但是理念，关键是理念，并不是每个人都能掌握的。所以，我不想介绍基础知识了，更重要的是我在使用过程中的经验、方法，对于肯于付出时间去尝试的人，他会从理念、方法中受益的！\r\n\r\n总结一下，经过这么长时间的使用，我用**笔记软件**主要做：<span style=\"color: #ff6600;\">**个人知识体系构建及管理、人生规划回顾与计划、其他备忘**</span>。我在这里说的是：“我用笔记软件”，而不是说我用“为知笔记”，这说明，只要掌握了这些理念，至于选择哪款软件并不那么重要，虽然我一直推荐使用的是<span style=\"color: #ff6600;\">**为知笔记**</span>！\r\n\r\n<span id=\"more-482\"></span>\r\n\r\n# 三、个人知识体系构建及管理\r\n\r\n这个名词比较简单，但是包含的内容比较多。一个人的知识体系需要以下的几个步骤才能够有效的构建和管理：\r\n\r\n> 1、明确<span id=\"0KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>需要什么样的知识，知识体系如何架构\r\n> \r\n> 2、按照<span id=\"1KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>构建好的知识体系框架，去搜集、验证、整理、存储、搜索知识\r\n> \r\n> 3、根据学习到的知识进行思考、实践应用后获得的属于个人的独特知识，这些独特知识的归档、使用、分享、再创造过程。\r\n\r\n## （一）需要什么知识，如何构架体系\r\n\r\n关于这部分的内容，我在之前的博客《[个人核心竞争力的打造-01](http://blog.hiddenwangcc.com/?p=432 \"个人核心竞争力的打造-01\")》和《[个人核心竞争力的打造-02](http://blog.hiddenwangcc.com/?p=437 \"个人核心竞争力的打造-02\")》做过具体说明，每个人都需要属于<span id=\"2KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>独特的知识和技能，并且需要把这部分内容和<span id=\"3KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>的经验相结合，就会产生属于<span id=\"4KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>的个人核心竞争力，而这部分知识可以分为：**进化能力、专业知识、其他方面知识、性格体系**四个方面.\r\n\r\n## （二）如何做好PIM\r\n\r\n这里的PIM指的是Personal Information Management，个人信息管理。它只是包括对知识的搜集、验证、整理、存储和搜索的过程，它是个人知识管理（PKM、Personal Knowledge Management）的<span style=\"color: #000000; background-color: #fff497;\">子集</span>，作为知识管理就必须要有知识的融合、提取、分享、再创造的过程。\r\n\r\n简单的说，所谓的PIM就是指资料收集、管理。目前的因特网资源浩瀚，究竟怎么样来保存<span id=\"6KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>感兴趣的资料呢？最简单的方法就是<span style=\"color: #ff6600;\">**按照类别设置目录分别存储，并通过标签来解决交叉学科的知识归档问题和未来知识的检索问题**</span>。\r\n\r\n## （三）如何做好知识的再创造\r\n\r\n这里我没有想好一个最贴切的词语，究竟什么叫做再创造。我的意思是经过PIM的资料如何转化为<span id=\"7KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>的东西，或者有个名次叫做**知识内化过程**。这是需要不断学习、思考和实践才能实现的，并且，这是进化能力的问题，不是为知笔记使用理念，所以不在这里累述。但是要想记录并可以随时分享<span id=\"8KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>的内化知识，还是需要为知笔记来帮忙的。\r\n\r\n我的方法是：按照我的知识体系的构架，分为进化能力、其他领域知识和技能，专业领域知识、性格体系、思考痕迹、生活指南几个部分。这里面的内容并不一定要有多少，但是全部都是<span id=\"9KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>思考过的知识，也就是说全部是内化了的知识。\r\n\r\n## （四）我的实际应用\r\n\r\n我在为知笔记中是这样建立目录的：\r\n\r\n> 2.1@知识体系\r\n> \r\n> 2.2@专业知识领域\r\n> \r\n> 2.3@性格体系\r\n> \r\n> 2.4@思考痕迹\r\n> \r\n> 2.5@生活指南\r\n> \r\n> 3.0@PIM系统\r\n\r\n这里之所以用@这个符号，并且在前面写上了数字，这样方便目录的排序。\r\n\r\n先说最后一个吧，**3.0@PIM系统**，这个就是用来搜集资料的，我把资料按照不同的类别去归档，归档的原则在第二点PIM如何使用中已经标明。\r\n\r\n**2.1@知识体系**中主要存放着关于我在进化能力和其他领域知识和技能方面的内化为<span id=\"10KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>的知识。\r\n\r\n**2.2@专业知识领域**中，我又分为两个部分，一个是工作总结及回顾，另外一个是专业知识学习。工作总结及回顾是非常必须的，它连接了我的时间管理中的归档和回顾系统，同时也连接了我的各种云端同步的资料系统，是我工作中不断提升进步的最重要的保障！\r\n\r\n**2.3@性格体系**，这个不言而喻了。\r\n\r\n**2.4@思考痕迹**，这里我放着我所有思考的内容，主要包括两个部分，**第一是比较长的内容**，主要是我写在博客上的思考内容（我通过为知的博客发布工具，每次都写好在为知上，然后再通过一键发布到博客，很爽）；另外一部分是那种给我感慨的某一句话或者一小段文字，我也都记录下来，有的就直接保留简短的句子，有的用于以后酝酿，发酵成新的思考内容。\r\n\r\n**2.5@生活指南**，这里是我<span id=\"11KSFindDIV\" class=\"KSFIND_CLASS\">自己</span>摸索出来的各种生活经验，比如说如何养成好习惯啊、如何规范化生活、最重要的是我生活中的一个愿景在这里孵化，那就是：**幸福进化联盟**。现在虽然还小，但是依然是那句话，不怕慢，就怕停，总有一天，这个联盟会发挥它的作用。\r\n\r\n",
        "category" : "qwzt",
        "postSummary" : " 一、我的使用历程\r\n\r\n最早开始使用笔记软件是在2008年初。有天，我因为无聊，打开了Office 2007的安装目录，其中发现一个我很少用的程序：Onenote。好奇心导致我打开了它，简单明了的指...",
        "sub_category" : "知识管理",
        "img_url" : "",
        "tag" : "为知笔记;知识管理；",
        "recommend" : true,
        "pv" : 1
    },

    /* 29 */
    {
        "_id" : ObjectId("5882bce23472f7282c346e09"),
        "author" : "yujian666",
        "title" : "我是怎样用为知笔记的-02",
        "content" : "# 四、人生规划回顾与计划\r\n\r\n人生是一次旅程，这条路没有一个固定的评价标准，但是每个人都希望自己走的路是一条有意义的路。所谓有意义，在我看来无非是两方面：**往后看，知道是怎么样一步一步走到现在的；往前看，知道未来要往哪里去**。那这就涉及到回顾和计划！\r\n\r\n有个人生六大高度理论，自下而上分为两个部分：**一是回顾部分**，自下而上有三个层次，分为**<span style=\"color: #ff6600;\">下一步行动</span>**（这是时间管理中的概念，主要包括**今天“必须”要做的事情**和当**自己空闲时能够做的事情**，一般就要看最底层高度的内容）、**<span style=\"color: #ff6600;\">任务</span>**（通常指的是项目，就是要实现自己短期目标时，要参考的高度）、**<span style=\"color: #ff6600;\">责任</span>**（当自己需要平衡的时候，要看这个高度的内容）。回顾的部分必须通过严格要求的定期回顾来实现，如果没有一种良好的回顾方式，对人生底层高度的把握是不到位的！而如果这方面无法把握，那么对人生的规划就更无从说起了。所以这里涉及到第二个大方面就是**<span id=\"0KSFindDIV\" class=\"KSFIND_CLASS_SELECT\">计划部分</span>**，这里和第一部分略有不同，要自上而下地看，包括**<span style=\"color: #ff6600;\">人生意义/原则</span>**（在自己要做重大决策的时候要参考这个部分）、**<span style=\"color: #ff6600;\">愿景</span>**（当自己需要动力和长期的方向时参照这个高度）、**<span style=\"color: #ff6600;\">目标</span>**（当确保自己能够得到自己预期的结果时，要经常看看自己的目标）。前面说了，<span id=\"1KSFindDIV\" class=\"KSFIND_CLASS\">计划部分</span>的圆满完成必须仰仗于完成有效的回顾才可以实现，没有现实的基础，看不清来时路而去谈未来怎么发展，那绝对是空中楼阁！\r\n\r\n[![我是怎样用为知笔记的-02-知行，在路上](http://s0.hiddenwangcc.com/201208/751/26197_o.png \"人生六大高度\")](http://s0.hiddenwangcc.com/201208/751/26197_o.png \"我是怎样用为知笔记的-02\")\r\n\r\n<span id=\"more-484\"></span>\r\n\r\n## （一）如何回顾\r\n\r\n我在实践中，为了能够很好的对应人生六大高度体系，我将我的**回顾分为每日回顾、每周回顾、每季回顾、每年回顾**。\r\n\r\n### **1、每日回顾。**\r\n\r\n经过我的反复摸索和不断改进，我确定了我每日回顾的内容，也制作了我的模板。我按照天为单位，建立每天回顾的日记，统一放置在**1.1@每日时间记录**文件夹中。\r\n\r\n我的模板是这样的：\r\n\r\n> **今日计划**\r\n> \r\n> * * *\r\n> \r\n> 1.\r\n> \r\n> 2.\r\n> \r\n> **时间流水账（**【工作】【总结】【浪费】【锻炼】【阅读】【思考】【专业】【兴趣】【规划】【生活】【学习】**）**\r\n> \r\n> * * *\r\n> \r\n> 日期：2012年06月12日 周二\r\n> \r\n> 天气：多云间阴有雷雨或阵雨，南风4-5级，19℃ - 27℃\r\n> \r\n> 05:30 - 06:30 【项目】……\r\n> \r\n> 06:30 - 07:20 【项目】……\r\n> \r\n> **时间开销总结**\r\n> \r\n> * * *\r\n> \r\n> 1.【项目】事件1：花费时间\r\n> \r\n> 2.\r\n> \r\n> **成功日记**\r\n> \r\n> * * *\r\n> \r\n> 1.今天有件事情挺开心的\r\n> \r\n> 2.\r\n> \r\n> 3.\r\n> \r\n> 4.\r\n> \r\n> 5.\r\n> \r\n> **每日必做项目**\r\n> \r\n> * * *\r\n> \r\n> □……\r\n> \r\n> □……\r\n\r\n这已经是我的第三版的模板了，我在这一版中删除了每日问题反省回顾、我最想要两个部分，因为我觉得这些问题不是一天两天可以处理解决的，所以我将其移至其他的目录中了。\r\n\r\n**今日<span id=\"2KSFindDIV\" class=\"KSFIND_CLASS\">计划部分</span>**，我每天都会处理两次，首先是当天的晚上会写下第二天的“今日计划”部分，这样可以对明天所作所为有个初步的意向。等到第二天早晨上班后，我会再次把“今日计划”的内容细化充实。当然了，这里有项目、有行动，如果想管理好自己的事项，我都会把每日确定好的计划整理到时间管理系统中去，这是必须的，不要指望笔记软件还可以高效的实现时间管理软件的功能。\r\n\r\n**时间流水账**部分，要以项目管理的方式来进行记录，只要进行了一件事情，就要开始一条新的时间记录。对于日期和天气，我觉得是必须要有的，据说人在不同天气情况下可以反映出不同的身体状态，记下来以后才能摸到自己身体的规律！另外，在最新的模板中，我按照《奇特的一生》的想法，加入了对不同项目的时间统计功能，项目类型我也写在上面了。\r\n\r\n**时间开销总结**部分，之所以在时间流水账中添加项目类型的内容，关键就是在每天晚上进行今天时间开销统计的时候，有迹可循。这样每天回顾再加上每周和每季度的回顾，就可以发现自己的时间究竟是放到哪里去了，这样就很容易在“责任范围”的高度上达到平衡！\r\n\r\n**成功日记**部分，按照成功日记的要求，每天必须记录五条自己成功、开心、快乐、愉悦、幸福的事情，只能是五条，这样，很容易就能看到自己的优点。\r\n\r\n**每日必做项目**部分，比如说要养成某种习惯，或者要强迫自己每天必须进行的项目就可以放在这里，这是我以前辅助表格的一种综合体现方式。因为对于我现在来说，我的心智能力足以管理自己，那么只需要把我每天需要做的内容，通过这种提醒的方式列出来就好了。每当完成的时候，就把前面的空心方框变成实心的就好了。\r\n\r\n### 2、每周、每季、每年回顾\r\n\r\n这个部分和上面的每日回顾比较接近，我就不把我的模板列出来了。因为每周、每季甚至每年的回顾，这种方式的高度就必须联系到人生规划的较高层的内容了，必须和自己人生愿景、目标相统一，每个人的目标不同，回顾的内容也就不同。我把这些内容统一放置在**1.2@周季年回顾**的目录中。\r\n\r\n切记切记，<span style=\"color: #ff6600;\">**必须对时间开销做出统计**</span>，这个方法对感知时间、掌控自己有着无比的优势！如果不明白如何做，就去把那本只有不到一百页的《奇特的一生》阅读一下吧！\r\n\r\n## （二）关于计划\r\n\r\n至于计划，更是因人而异。但是刚才在提到人生高度的时候，说到这个部分，必须从最高的人生意义/原则入手，然后再往下的高度来确定，我在为知笔记中建立了**1.3@人生规划**目录，按照不同的高度建立了子文件夹，我举例来说明一下吧（例子来自《小强升职记》）\r\n\r\n> **人生意义/原则：**创造更好的生活\r\n> \r\n> **愿景：**\r\n> \r\n> 事业：能在公司中实现自己的价值，成为高层主管，至少漂亮地完成一个让自己引以为傲的重要项目。\r\n> \r\n> 财富：通过自己的努力达到年薪20万，并且通过投资基金和房地产使自己的资产每年增长15%-20%。\r\n> \r\n> 健康：保持良好的体力，将体重控制在160斤以下。\r\n> \r\n> 生活：保持良好的心态，尽量减少工作对生活的干扰，保证和家人在一起的时间，尽量改善家里的生活条件\r\n> \r\n> **&nbsp;目标：**\r\n> \r\n> 事业：两年之内成为项目主管。\r\n> \r\n> 财富：学习理财和投资知识；拓展人脉，寻找更好的投资机会。\r\n> \r\n> 健康：加入健身俱乐部，坚持每周锻炼三次；每周打一次篮球或羽毛球；戒烟，少喝酒，保证睡眠，科学饮食，养成良好的健康习惯。\r\n> \r\n> 生活：每年出去旅游两次；每周回父母家一次；每天都将工作的压力放在扔在办公室。\r\n\r\n有很多人有着这样的说法：**计划不如变化快**。我不否认这句话和这个事实的存在，但是，很多人在用这句话的时候，把它当成自己偷懒不做计划的一个借口！这个计划必须要有的，人生意义和原则变化并不大，愿景的确定基本上以五年为一个调整期，而目标则应该每季度有所变化。而这样，也就可以跟之前的回顾部分有机的结合起来了。\r\n\r\n在我看来，只有严格要求自己，不断做好每日记录，每周、季、年回顾，同时根据自己每天走的路，不断修正自己的目标和愿景，最终实现自己的人生价值，恕我狂妄，我认为只有这样，才能真正走上一条有意义的人生之路！\r\n\r\n&nbsp;",
        "category" : "qwzt",
        "postSummary" : " 四、人生规划回顾与计划\r\n\r\n人生是一次旅程，这条路没有一个固定的评价标准，但是每个人都希望自己走的路是一条有意义的路。所谓有意义，在我看来无非是两方面：往后看，知道是怎么样一步一步走到现在的；往前...",
        "sub_category" : "知识管理",
        "img_url" : "",
        "tag" : "为知笔记;知识管理；",
        "recommend" : false,
        "pv" : 1
    },

    /* 30 */
    {
        "_id" : ObjectId("5882bddd3472f7282c346e0a"),
        "author" : "yujian666",
        "title" : "收集的资料从来不看怎么办？",
        "content" : "## 〇、引言\r\n\r\n这是一个朋友提出的问题：“为何在看到好的资料时**费时费力**收集下来，之后却长时间甚至**一直都不看**，这种心理或者思维方式应该怎么解决？”想想就做了一篇回答，从几个角度给出一些提示。\r\n\r\n## 一、三个角色\r\n\r\n> M：我叫心理。\r\n> \r\n> TM：我叫思维模式。\r\n> \r\n> M&TM：<span style=\"color: #ff6600;\">**为什么，什么都要往我们身上揽啊！我们招谁惹谁了啊**！</span>\r\n> \r\n> H：我叫做习惯，看到有人吐槽了，我脸红了……\r\n\r\n当我看到这个话题的时候，脑海中首先出现的就是这三个小人在吵架的场景！这完全不是心理和思维方式的问题，而是一些**行动的方法论不具备**。所谓方法论，就是指**<span style=\"color: #ff6600;\">把事情做对的习惯</span>**，这件事情上，指的就是把<span style=\"color: #ff6600;\">**资料内化的习惯不具备**</span>。还是不偏离问题了，我给出几个解决方案：\r\n\r\n## 二、解决方案\r\n\r\n### （一）费时费力收集下来\r\n\r\n如果看到资料**需要费时费力**地收集下来，那肯定是有问题的。收集本身是一个非常简单方便的过程，不太需要费什么力气。<span style=\"color: #ff6600;\">**我推荐使用印象笔记来进行资料收集**</span>。\r\n\r\n> 1. 在电脑上安装收集插件——剪藏。推荐使用猎豹浏览器或者Chrome浏览器，然后安装**印象笔记·剪藏**（[点击访问](http://www.yinxiang.com/webclipper/)），它会给你个简单的教程的，当你遇到好资料的时候，可以很方便地收集，不需要费时费力。\r\n> \r\n> 2. 在手机上安装印象笔记。安装了印象笔记软件后，在任何一个app中，只要选中文字，就可以将文字共享到印象笔记中去。\r\n\r\n因为印象笔记操作起来比较简单，所以，我写的也很简单。我觉得题主主要想解决后面的问题，所以，我把精力也留在后面。\r\n\r\n### （二）很长时间都不看，该怎么办？\r\n\r\n因为题主并没有描述自己的基本情况，所以，分析起来就有多种可能，希望不要说我啰嗦。\r\n\r\n**1. 不知道自己到底想要什么**\r\n\r\n自己的目标并不是很明确。<span style=\"color: #ff6600;\">**不知道什么才是自己创造价值过程中的必需品**</span>。没有一个精深的方向，所以，只能在每个自己感兴趣的领域中浅尝辄止。要知道，这是一个物质和信息极度爆炸的时代，任何一个领域中都可能让自己感兴趣。如果这样，把自己感兴趣的信息都收集下来，就会出现题主的问题：收集的广而杂，但是不知道要精深哪个。所以，我的建议是：**<span style=\"color: #ff6600;\">要想标本兼治，先去找到自己的目标</span>**！\r\n\r\n**2. 有个隐藏的惰性思维**\r\n\r\n人们自远古进化而来，停止不动保存能量成为古人活下来的一种必须。懒惰，看似是远古生存的必备要素，已经深藏在现代的人类内心。我们都期待着不劳而获，或者少劳多获！甚至，通过自我欺骗的方式来让自己相信，自己做一点点努力，就可以得到很大的收获。这个问题就是一个实例！你期待的是通过阅读大量的资料来获得自我的提升，但是，你的大脑告诉你：“亲，咱们收集下来，就可以实现自我提升了”，于是，我们就会变得如同疯狂一般，不断地搜集有关无关的各种资料，让自己感觉到自己很厉害！\r\n\r\n现在，我们都知道，收集资料不代表拥有资料！揪出懒惰的进化基因，用新的行为方式和它进行斗争吧。\r\n\r\n**3. 如何消化、沉淀资料**\r\n\r\n这个问题，其实归属于个人知识管理流程中的消化、沉淀环节。个人知识管理，主要有几个重要的环节：\r\n\r\n1.  收集\r\n2.  存储\r\n3.  消化\r\n4.  沉淀\r\n5.  分享\r\n6.  应用\r\n7.  创新\r\n\r\n所谓的<span style=\"color: #ff6600;\">**消化，指的就是把所有存储的资料仔细阅读，去粗取精**</span>。所谓的<span style=\"color: #ff6600;\">**沉淀，就是将有用的内容不断结构化、系统化，对接到自己原有的知识体系中去**</span>。从这两点中，其实就引出了两个行动，<span style=\"color: #ff6600;\">**一个是阅读资料，一个是整理知识框架**。</span>\r\n\r\n## 三、想要做好消化、沉淀，需要养成什么样的习惯\r\n\r\n从上面的分析来看，题主要是想解决问题，要养成两个习惯：\r\n\r\n### （一）阅读资料\r\n\r\n阅读资料，有两种方式，一个是眼看，一个是耳听，两者我都会用。\r\n\r\n**1. 眼看的关键**。所谓的眼看，就是传统的阅读，我们这个时代，事情多、时间少，我们必须要有一个能力：<span style=\"color: #ff6600;\">**看一遍就能把有用的内容都萃取出来的能力**</span>。通常，阅读的对象有纸质资料和电子资料两类。这个问题就很庞大了，我就不展开说了，网上有很多关于纸质资料阅读和电子资料阅读的方式，无论怎么做，一定要记住，要培养从资料中萃取精华的能力！\r\n\r\n**2. 耳听的关键。**毕竟，没有那么多时间来阅读，所以，要利用更多的方式，耳朵，就是另外一个重要的信息输入源。通常，我会在走路、开车或者锻炼的时候用手机来听资料，一篇很长的资料，在走路的十几分钟内就可以听完，回来再进行萃取就简单很多。我是安卓手机，方法是：安装一个叫做Voice Aloud的软件，然后打开印象笔记中的某一篇笔记，按住屏幕，全后全选文字，再点共享按钮，发送到Voice Aloud中去，它就会开始朗读的。<span style=\"color: #ff6600;\">**这种方法是非常节省时间的！**</span>Google Play下载地址：[@Voice Aloud Reader-Read Aloud](https://play.google.com/store/apps/details?id=com.hyperionics.avar)\r\n\r\n![收集的资料从来不看怎么办？-知行，在路上](http://s2.hiddenwangcc.com/201404/751/44466_z.jpg)\r\n\r\n### （二）整理知识框架\r\n\r\n对于还没有知识框架的人来说，这一点比较难以理解。我用我自己的经历来举例子：\r\n\r\n我最早的时候刚接触到时间管理GTD，觉得很牛逼，学完了之后，做了个流程的脑图，后来发现，这个框架有问题，于是我就寻找六大高度理论究竟是什么。在实践掌握之后，我又发现，没有妥善的知识管理，仿佛有种中毒的感觉！……忽然有一天，我发现，这些点是串联在一起的，这个框架就合成到一起了！\r\n\r\n于是，我做了个脑图\r\n\r\n![收集的资料从来不看怎么办？-知行，在路上](http://s0.hiddenwangcc.com/201402/751/43383_z.jpg)\r\n\r\n（本图在与您共享栏目中可下载大图）\r\n\r\n把这三者都串联到一起后，以后再有任何关于自我管理的知识，我可以很轻松地修改这个框架，让别人的知识成为自己的一部分。\r\n\r\n所以，如果你还没有知识体系，不要担心，用脑图（Mindmanager、Xmind）来把自己萃取过的精华都分类记录下来，坚持这么做，框架会在某一天瞬间到你的眼前！\r\n\r\n### （三）坚持养成习惯\r\n\r\n上面的过程看似简单，其实必须要有好的习惯来支撑。关于习惯养成，我以前有讲过类似的课程，我的博客上也有关于习惯养成的系列文章（点击访问第一篇：[习惯养成方法与实践01：为什么要养成习惯](http://blog.hiddenwangcc.com/archives/610)），我也在多贝网和沪江网上开课讲关于习惯养成的内容。\r\n\r\n好了，不做广告了，我建议，养成<span style=\"color: #ff6600;\">**每个周末清空印象笔记收集箱**</span>的习惯，以及<span style=\"color: #ff6600;\">**每天做一个精华材料的脑图**</span>习惯。试试看，你会变的不一样的！\r\n\r\n## 四、结尾\r\n\r\n为什么，我一回答问题，就是长篇大论，这是不是心理或者思维模式的问题？\r\n\r\nM&TM：你妹……",
        "category" : "qwzt",
        "postSummary" : " 〇、引言\r\n\r\n这是一个朋友提出的问题：“为何在看到好的资料时费时费力收集下来，之后却长时间甚至一直都不看，这种心理或者思维方式应该怎么解决？”想想就做了一篇回答，从几个角度给出一些提示。\r\n\r\n ...",
        "sub_category" : "知识管理",
        "img_url" : "",
        "tag" : "为知笔记;知识管理；",
        "recommend" : false,
        "pv" : 2
    },

    /* 31 */
    {
        "_id" : ObjectId("5882bf053472f7282c346e0b"),
        "author" : "yujian666",
        "title" : "各种 真机远程调试 方法 汇总",
        "content" : "“真机远程调试”（remote inspect web on real device），是指用桌面电脑（PC或MAC）远程连接上移动设备，通过类似Chrome浏览器开发人员工具的界面，来调试移动设备上运行的网页\r\n\r\n### 总览表格\r\n\r\n<table>\r\n<tbody>\r\n<tr>\r\n\t\t<td>方法\t\t\t\t\t\t</th>\r\n\t\t<td>关键点\t\t\t\t\t\t</td>\r\n\t\t<td>实现难度（综合考虑搭环境、软件、硬件成本，分数 **小** 为佳）\t\t</td>\r\n\t\t<td>调试效果（综合考虑仿真效果、能调试的项等，分数 **大** 为佳）\t\t</td>\r\n\t\t<td>可用的桌面设备\t\t</td>\r\n\t\t<td>可用的移动设备及可调试的浏览器\t</td>\r\n\t\t<td>简要步骤\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>Chrome模拟器\t\t\t\t</td>\r\n\t\t<td>非真机，只是模拟\t\t\t\t</td>\r\n\t\t<td>0\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>2（新版本加入了模拟网络链接的功能，故上调评分）\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>无\t\t\t\t\t\t\t\t</td>\r\n\t\t<td> [GO](#chrome%E6%A8%A1%E6%8B%9F%E5%99%A8) \t\t\t\t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>weinre\t\t\t\t\t\t</td>\r\n\t\t<td>安装较为繁琐\t\t\t\t\t</td>\r\n\t\t<td>3\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>2\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>全部\t\t\t\t\t\t\t</td>\r\n\t\t<td> [GO](#weinre)\t\t\t\t\t\t\t \t\t\t\t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>spy-debugger (简化weinre配置，支持https)\t  </td>\r\n\t\t<td>需要桌面设备和移动设备同一网段  </td>\r\n\t\t<td>2\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>2\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>全部\t\t\t\t\t\t\t</td>\r\n\t\t<td> [GO](#spy-debugger)\t\t\t\t\t\t\t \t\t\t\t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>调试Android上的Chrome\t \t</td>\r\n\t\t<td>需要翻墙\t\t\t\t\t\t</td>\r\n\t\t<td>2\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>4\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>Android上的Chrome\t\t\t\t</td>\r\n\t\t<td> [GO](#%E8%B0%83%E8%AF%95android%E4%B8%8A%E7%9A%84chrome) \t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>调试Android APP里的webview \t</td>\r\n\t\t<td>需要翻墙\t\t\t\t\t\t</td>\r\n\t\t<td>3\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>4\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>Android APP里的webview\t\t\t</td>\r\n\t\t<td> [GO](#%E8%B0%83%E8%AF%95android-app%E9%87%8C%E7%9A%84webview) \t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>调试Android上的x5内核（微信等）</td>\r\n\t\t<td>安装较为繁琐\t\t\t\t\t</td>\r\n\t\t<td>3\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>5\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>Android上的应用了x5内核的app，如微信、手Q、QQ浏览器等</td>\r\n\t\t<td> [GO](#%E8%B0%83%E8%AF%95android%E4%B8%8A%E7%9A%84x5%E5%86%85%E6%A0%B8) \t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>调试Android上的UC\t\t \t</td>\r\n\t\t<td>需要桌面设备和移动设备同一网段\t</td>\r\n\t\t<td>1\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>3\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>PC、MAC\t\t\t\t</td>\r\n\t\t<td>Android上的UC\t\t\t\t\t</td>\r\n\t\t<td> [GO](#%E8%B0%83%E8%AF%95android%E4%B8%8A%E7%9A%84uc) \t\t\t</td>\r\n\t</tr>\r\n\t<tr>\r\n\t\t<td>调试iOS上的Safari\t\t \t</td>\r\n\t\t<td>需要MAC（甚至可以无需iOS设备）\t</td>\r\n\t\t<td>2\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>4\t\t\t\t\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t<td>MAC\t\t\t\t</td>\r\n\t\t<td>iOS上的Safari\t\t\t\t\t</td>\r\n\t\t<td> [GO](#%E8%B0%83%E8%AF%95ios%E4%B8%8A%E7%9A%84safari) \t\t\t</td>\r\n\t</tr>\r\n</tbody></table>\r\n\r\n## 简要步骤\r\n\r\n###Chrome模拟器\r\n\r\n1.  在PC或MAC上打开Chrome浏览器，打开想要调试的页面，然后打开开发人员工具\r\n2.  点击开发人员工具顶栏上的手机图标，即可开始调试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/Chrome模拟器_4.png) ），一般来说需要重新刷新页面\r\n3.  在页面顶部可以看到设备选择下拉菜单 `Device` 和 模拟网络环境的下拉菜单 `Network` ，及左侧的清除选择按钮和打开关闭 `media queries` 的按钮（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/Chrome模拟器_5.png) ）\r\n4.  打开设置左边的那个类似 `>三` 的图标，切换到 `Emulation` 标签，可以更细粒度地调整，来定制化你的模拟（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/Chrome模拟器_6.png) ）\r\n\r\n### weinre\r\n\r\n过程稍微繁琐，但是这个方案能调试几乎所有平台的所有浏览器，只要能运行js的就行\r\n\r\n1. 安装nodejs \r\n\r\n2. 安装weinre到global，即在命令行中运行 `npm -g install weinre` （MAC可能需要在前面加上 `sudo` ）\r\n\r\n3. 获取本机IP地址（PC：开始→运行→cmd，输入 `ipconfig` ，查看“IPv4地址”字段； MAC：在网络偏好设置内），假设获取到的IP地址为 `4.4.4.4`\r\n\r\n4. 在命令行运行weinre： `weinre --boundHost 4.4.4.4` ，其中IP地址为上一步所获取的地址，如果弹出防火墙，请允许访问（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/weinre_1.jpg) ）\r\n\r\n5. 在PC或MAC上用浏览器打开 `http://4.4.4.4:8080/client/#anonymous` ，其中IP地址为第三步所获取的地址（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/weinre_2.jpg) ）\r\n\r\n6. 将移动设备连接到与PC或MAC同一局域网，打开移动设备上的需要调试的浏览器，然后随便打开一个网页。将它保存为书签\r\n\r\n7. 修改上述书签，将地址改成：\r\n\r\n<pre>javascript:(function(e){e.setAttribute(\"src\",\"http://4.4.4.4:8080/\r\ntarget/target-script-min.js#anonymous\");document.getElementsByTagName(\"body\")[\r\n0].appendChild(e);})(document.createElement(\"script\"));void(0);</pre>\r\n\r\n，其中IP地址为第三步所获取的地址（复制后请去掉代码中的换行，使之成为一行）\r\n\r\n8. 在移动设备浏览器上打开想要调试的页面，然后点击上一步保存的书签，即可在PC或MAC上的页面中的target中找到对应页面，点击可以开始调试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/weinre_3.jpg) ）（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/weinre_4.png) ）\r\n\r\n更多：\r\n\r\n1.  可以考虑在某个机器上搭建一个统一的weinre服务器，供团队成员共用，此方案我尚未尝试\r\n2.  在上述第7步开始，可以不采用书签的形式，而是考虑在代码中引入它提供的调试js文件，如 `<script src=\"http://4.4.4.4:8080/target/target-script-min.js#anonymous\"></script>` （这种情况适用于不能使用书签的场景，如app内的webview、微信中等，但是上线之前要记得移除这个js的引用）\r\n\r\n其他参考链接\r\n\r\n*   [http://people.apache.org/~pmuellr/weinre-docs/latest/Installing.html](http://people.apache.org/~pmuellr/weinre-docs/latest/Installing.html)\r\n\r\n### spy-debugger(集成weinre)\r\n\r\n内部集成了weinre，简化了weinre繁琐的配置过程。通过代理的方式拦截所有html自动注入weinre所需的js代码。\r\n\r\n1. 安装\r\n\r\n    Windows:  `npm install spy-debugger -g`\r\n\r\n    Mac:      `sudo npm install spy-debugger -g`\r\n\r\n2. 手机和PC保持在同一网络下（比如同时连到一个Wi-Fi下）\r\n\r\n3. 命令行输入spy-debugger，按命令行提示用浏览器打开相应地址。\r\n\r\n4. 设置手机的HTTP代理，代理IP地址设置为PC的IP地址，端口为spy-debugger的启动端口。\r\n\r\n5. 用手机浏览器访问你要调试的页面即可。\r\n\r\n其他参考链接\r\n\r\n*   [https://github.com/wuchangming/spy-debugger](https://github.com/wuchangming/spy-debugger)\r\n\r\n### 调试Android上的Chrome\r\n\r\n1.  在Android设备上安装Chrome浏览器（版本>=32，[https://play.google.com/store/apps/details?id=com.android.chrome&hl=en](https://play.google.com/store/apps/details?id=com.android.chrome&hl=en) ）（只有安卓4.0以上才有Chrome）\r\n2.  开启当前Android设备的USB调试\r\n3.  在PC或MAC上安装chrome浏览器（版本>=32）和对应的Android设备驱动（如果找不到，可以在这个 [列表](http://developer.android.com/tools/extras/oem-usb.html) 内尝试）\r\n4.  用USB线连接Android设备，在PC或MAC上的chrome地址栏输入 `chrome://inspect` 然后回车，或通过菜单图标→工具→检查设备，进入调试界面\r\n5.  勾选界面中的 `Discover USB devices` ，直到搜索到你的Android设备（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的Chrome_1.png) ）\r\n6.  在移动设备上弹出的是否允许远程调试上，选择“允许”\r\n7.  在下面的页面列表（将展示已在Android上的chrome中打开的页面），点击对应的 `inspect` 开始调试\r\n8.  此时将在桌面版Chrome上弹出一个新的标签页，即为调试界面；如果很久都没用响应，请翻墙后再试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的Chrome_2.png) ）（ [一个免费的梯子服务](http://lfjs.me/gwrbea) ）（ [免费10天稳定梯子服务](http://honx.in/_U6fKbIKo102euHSx) ）\r\n\r\n其他参考链接\r\n\r\n*   [https://developer.chrome.com/devtools/docs/remote-debugging](https://developer.chrome.com/devtools/docs/remote-debugging)\r\n\r\n### 调试Android APP里的webview\r\n\r\n1.  通过修改代码，在APP内设置允许远程调试（需安卓版本为4.4及以上）： [方法](https://developer.chrome.com/devtools/docs/remote-debugging#configure-webview) ，然后安装APP\r\n2.  开启当前Android设备的USB调试\r\n3.  在PC或MAC上安装chrome浏览器（版本>=32）和对应的Android设备驱动（如果找不到，可以在这个 [列表](http://developer.android.com/tools/extras/oem-usb.html) 内尝试）\r\n4.  用USB线连接Android设备，在PC或MAC上的chrome地址栏输入 `chrome://inspect` 然后回车，或通过菜单图标→工具→检查设备，进入调试界面\r\n5.  勾选界面中的 `Discover USB devices` ，直到搜索到你的Android设备（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的Chrome_1.png) ）\r\n6.  在移动设备上弹出的是否允许远程调试上，选择“允许”\r\n7.  在下面的页面列表（将展示已在Android上的chrome中打开的页面），点击对应的 `inspect` 开始调试\r\n8.  此时将在桌面版Chrome上弹出一个新的标签页，即为调试界面；如果很久都没用响应，请翻墙后再试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的Chrome_2.png) ）（ [一个免费的翻墙服务](http://lfjs.me/gwrbea) ）\r\n\r\n其他参考链接\r\n\r\n*   [https://developers.google.com/chrome-developer-tools/docs/remote-debugging](https://developers.google.com/chrome-developer-tools/docs/remote-debugging)\r\n\r\n###调试Android上的x5内核\r\n\r\n过程略繁琐，但是这个方案应该是目前调试webview最强大的工具，支持断点调试、控制台打印等。以下步骤以微信6.1举例：\r\n\r\n**前期准备**\r\n\r\n*   下载 [TbsSuiteNew.apk](http://res.imtt.qq.com///tbs_inspect/TbsSuiteNew.zip) 安装到手机\r\n*   打开微信，进入任意聊天界面，输入框内输入//deletetbs，点发送\r\n*   打开TbsSuiteNew，安装本地tbs内核（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的x5内核_1.png) ）\r\n> 应用包名 微信：com.tencent.mm，qq：com.tencent.mobileqq，qq空间：com.qzone\r\n> \r\n> 我们选择微信即可\r\n\r\n*   启动应用，用微信访问一个页面，停留1分钟左右，目的是让微信来静默安装刚导入进去的tbs_xxxx_inspector.apk包（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的x5内核_2.png) ）\r\n*   一分钟过后打开TbsSuiteNew 检查是否安装成功。（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的x5内核_3.png) ）\r\n> 这里还需要在检查下 打开微信 随便进入一个 webview页面 然后长按页面文字是否有水滴 ，若有则成功\r\n\r\n**ADB安装**\r\n\r\n*   官网下载 [android-sdk](http://developer.android.com/sdk/installing/index.html) ，执行tools文件夹下面的android，然后选择android sdk platform tools 安装（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的x5内核_4.png) ）\r\n*   配置android环境变量 vim ~/.bash_profile\r\n\r\n    export ANDROID_TOOLS=/Users/sherlock/dev/android-sdk-macosx/platform-tools\r\n    export PATH=$PATH:$ANDROID_TOOLS`</pre>\r\n\r\n*   输入source .bash_profile，执行下环境变量；接着在终端输入adb，看是否已经配置ok；\r\n*   usb连接手机，启动调试模式。终端输入adb devices，就能看到已经连接的设备。\r\n    > 有时 adb devices不能显示连接设备，需要拔掉数据线，多插几次，并且退出终端，然后重新打开，重启adb。\r\n\r\n    **python启动调试服务**\r\n\r\n*   下载 [调试包](http://res.imtt.qq.com///tbs_inspect/wx_sq_webview_debug.zip) ，解压，找到其中的inspector_client20150401 解压，然后进入\r\n*   执行以下python命令， python ./inspector.py —abd 你自己的adb路径\r\n    <pre>`python ./inspector.py --adb /Users/sherlock/dev/android-sdk-macosx/platform-tools/adb\r\n\r\n*   启动成功，PC打开chrome浏览器，访问 [http://localhost:9222/](http://localhost:9222/) ；手机打开微信任意webview，就能在chrome看到这个页面的选项卡，点进去就是熟悉的调试界面，请自由的使用～（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的x5内核_5.png) ）\r\n\r\n其他参考链接\r\n\r\n*   [http://www.jianshu.com/p/ccf124f1f74b](http://www.jianshu.com/p/ccf124f1f74b)\r\n\r\n### 调试Android上的UC\r\n\r\n1.  在Android设备上安装UC浏览器开发版，[http://www.uc.cn/business/developer/](http://www.uc.cn/business/developer/) ，点击第一行右侧的“安装包下载”（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的UC_1.png) ）\r\n2.  获取Android设备的IP，一般在WLAN设置内，假设为 `4.4.4.4`\r\n3.  用和手机处于同一网段的PC或MAC访问步骤2获得的IP后加上 `:9998` ，如例子中即为 `4.4.4.4:9998`\r\n4.  在Android设备上弹出的是否允许远程调试上，选择“允许”（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的UC_2.png) ），即可开始调试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试Android上的UC_3.png) ）\r\n\r\n其他参考链接\r\n\r\n*   [http://www.uc.cn/business/download/developer.pdf](http://www.uc.cn/business/download/developer.pdf)\r\n\r\n### 调试iOS上的Safari\r\n\r\n1.  在iOS设备上打开允许调试：设置→Safari→高级→打开”web检查器“\r\n2.  在MAC上打开Safari的开发菜单：顶部菜单栏“Safari”→偏好设置→高级→打开”在菜单栏中显示“开发”菜单\r\n3.  在iOS设备上的Safari浏览器中打开要调试的页面，然后切换到MAC的Safari，在顶部菜单栏选择“开发”→找到你的iOS设备名称→右边二级菜单选择需要调试的对应标签页，即可开始远程调试（ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试iOS上的Safari_1.png) ）\r\n4.  如果没有iOS设备，也可以在Xcode中模拟一台，点击顶部“Xcode”→“Open Developer Tool”→“iOS Simulator”即可打开一个iOS设备的模拟器，并且模拟器里面Safari打开的页面，也是能通过上个步骤中MAC上的Safari调试。 （ [示意图](/jieyou/remote_inspect_web_on_real_device/blob/master/images/调试iOS上的Safari_2.png) ）",
        "category" : "xwzj",
        "postSummary" : "“真机远程调试”（remote inspect web on real device），是指用桌面电脑（PC或MAC）远程连接上移动设备，通过类似Chrome浏览器开发人员工具的界面，来调试移动设备上...",
        "sub_category" : "tools",
        "img_url" : "",
        "tag" : "debug",
        "recommend" : true,
        "pv" : 10
    },

    /* 32 */
    {
        "_id" : ObjectId("5882c2db3472f7282c346e0d"),
        "author" : "yujian666",
        "title" : "Chrome调试前端页面的若干技巧",
        "content" : "## 一.先来认识一下这些按钮的功能\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228223631938?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**重点内容**先来看这张图最上头的一行是一个功能菜单，每一个菜单都有它相应的功能和使用方法，依次从左往右来看\r\n\r\n**1.箭头按钮**：用于在页面选择一个元素来审查和查看它的相关信息，当我们在Elements这个按钮页面下点击某个Dom元素时，箭头按钮会变成选择状态\r\n\r\n**2.设备图标**：点击它可以切换到不同的终端进行开发模式，移动端和pc端的一个切换，可以选择不同的移动终端设备，同时可以选择不同的尺寸比例，chrome浏览器的模拟移动设备和真实的设备相差不大，是非常好的选择\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228223915752?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**3.Elements 功能标签页**：用来查看，修改页面上的元素，包括DOM标签，以及css样式的查看，修改，还有相关盒模型的图形信息，下图我们可以看到当我鼠标选择id 为lg_tar的div元素时，右侧的css样式对应的会展示出此id 的样式信息，此时可以在右侧进行一个修改，修改即可在页面上生效， 灰色的element.style样式同样可以进行添加和书写，唯一的区别是，在这里添加的样式是添加到了该元素内部，实现方式即：该div元素的style属性，这个页面的功能很强大，在我们做了相关的页面后，修改样式是一块很重要的工作，细微的差距都需要调整，但是不可能说做到每修改一点即编译一遍代码，再刷新浏览器查看效果，这样很低效，一次性在浏览器中修改之后，再到代码中进行修改对应的样式\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224043612?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224018533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n盒模型信息\r\n\r\n同时，当我们浏览网站看到某些特别炫酷的效果和难做的样式时候，打开这个功能，我们即可看到别人是如何实现的，学会它这知识就是你的了，仔细钻研也会有意想不到的收获\r\n\r\n**4.Console控制台**：用于打印和输出相关的命令信息，其实console控制台除了我们熟知的报错，打印console.log信息外，还有很多相关的功能，下面简单介绍几个\r\n\r\n**a**: 一些对页面数据的指令操作，比如打断点正好执行到获取的数据上，由于数据都是层层嵌套的对象，这个时候查看里面的key/value不是很方便，即可用这个指令开查看，obj的json string 格式的key/value，我们对于数据里面有哪些字段和属性即可一目了然\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224433624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**b**: 除了console.log还有其他相关的指令可用\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224450656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**5.Sources js资源页面**：这个页面内我们可以找到当然浏览器页面中的js 源文件，方便我们查看和调试，在我还没有走出校园时候，我经常看一些大站的js代码，那时候其实基本都看不懂，但是最起码可以看看人家的代码风格，人家的命名方式，所有的代码都是压缩之后的代码，我们可以点击下面的{}大括号按钮将代码转成可读格式\r\n\r\nSources Panel 的左侧分别是 Sources 和 Content scripts和Snippets\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224515192?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n对应的源代码\r\n\r\n![格式化后的代码](http://img.blog.csdn.net/20161228224806067?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n格式化后的代码\r\n\r\n关于打断点调试的内容，下面介绍，先来说一些，其他平时基本没人用但是很有用的小点，比如当我们想不起某个方法的具体使用时候，会打开控制台随意写一些[测试](http://lib.csdn.net/base/softwaretest \"软件测试知识库\")代码，或者想测试一下刚刚写的方法是否会出现期待的样子，但是控制台一打回车本想换行但是却执行刚写的半截代码，所以推荐使用Sources下面的左侧的Sinppets代码片段按钮，这时候点击创建一个新的片段文件，写完测试代码后把鼠标放在新建文件上run，再结合控制台查看相关信息**（新建了一个名叫：app.js的片段代码，在你的项目环境页面内，该片段可执行项目内的方法）**\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228224835959?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n自己书写的片段\r\n\r\nContent scripts 是 Chrome 的一种扩展程序，它是按照扩展的ID来组织的，这些文件也是嵌入在页面中的资源，这类文件可以读写和操作我们的资源，需要调试这些扩展文件，则可以在这个目录下打开相关文件调试，但是几乎我们的项目还没有相关的扩展文件，所以啥也看不到，平时也不需要关心这块\r\n\r\n![无结果](http://img.blog.csdn.net/20161228224852084?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**6.Network 网络请求标签页**：可以看到所有的资源请求，包括网络请求，图片资源，html,css，js文件等请求，可以根据需求筛选请求项，一般多用于网络请求的查看和分析，分析后端接口是否正确传输，获取的数据是否准确，请求头，请求参数的查看\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225109680?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n所有的资源\r\n\r\n以上我选择了All，就会把该页面所有资源文件请求下来，如果只选择XHR 异步请求资源，则我们可以分析相关的请求信息\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225132101?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n请求的相关信息\r\n\r\n打开一个Ajax异步请求，可以看到它的请求头信息，是一个POST请求，参数有哪些，还可以预览它的返回的结果数据，这些数据的使用和查看有利于我们很好的和后端工程师们联调数据，也方便我们前端更直观的分析数据\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225153634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n预览请求的数据\r\n\r\n**7.Timeline标签页**可以显示JS执行时间、页面元素渲染时间，不做过多介绍\r\n\r\n**8.Profiles标签页**可以查看CPU执行时间与内存占用，不做过多介绍\r\n\r\n**9.Resources标签页**会列出所有的资源，以及[HTML5](http://lib.csdn.net/base/html5 \"HTML5知识库\")的Database和LocalStore等，你可以对存储的内容编辑和删除 不做过多介绍\r\n\r\n**10.Security标签页** 可以告诉你这个网站的安全性，查看有效的证书等\r\n\r\n**11.Audits标签页** 可以帮你分析页面性能，有助于优化前端页面，分析后得到的报告\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225217836?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n分析结果\r\n\r\n## <a name=\"t1\"></a>二.Sources资源页面的断点调试\r\n\r\n**1.如何调试：** \r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225244492?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n调试js代码，肯定是我们常用的功能，那么如何打断点，找到要调试的文件，然后在内容源代码左侧的代码标记行处点击即可打上一个断点\r\n\r\n**2.断点与 js代码修改**\r\n\r\n看下面这张图，我在一个名为toggleTab的方法下打了两个断点，当开始执行我们的点击切换tab行为后，代码会在执行的断点出停下来，并把相关的数据展示一部分，此时可以在已经执行过得代码处，把鼠标放上去，即可查看相关的具体数据信息，同时我们可以使用右侧的功能键进行调试，右侧最上面一排分别是：暂停/继续、单步执行(F10快捷键)、单步跳入此执行块(F11快捷键)、单步跳出此执行块、禁用/启用所有断点。下面是各种具体的功能区\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225317946?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n在代码中打断点\r\n\r\n在当前的代码执行区域，在调试中如果发现需要修改的地方，也是可以立即修改的，修改后保存即可生效，这样就免去了再到代码中去书写，再刷新回看了\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225338884?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast) \r\n\r\n临时修改\r\n\r\n**3.快速进入调试的方法**\r\n\r\n当我们的代码执行到某个程序块方法处，这个方法上可能你并没有设置相关的断点，此时你可以F11进入此程序块，但是往往我们的项目都是经过很多源代码封装好的方法，有时候进入后，会走很多底层的封装方法，需要很多步骤才能真正进入这个函数块，此时将鼠标放在此函数上，会出现相关提示，会告诉你在该文件的哪一行代码处，点击即可直接看到这个函数，然后临时打上断点，按F10或者点击右上角的第二个按钮即可直接进入此函数的断点处\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225356590?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**4.调试的功能区域**\r\n\r\n每一个功能区，都有它相关的左右，先来看一张图，它都有哪些功能\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225410231?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\nCall Stack调用栈：当断点执行到某一程序块处停下来后，右侧调试区的 Call Stack 会显示当前断点所处的方法调用栈，从上到下由最新调用处依次往下排列，Call Stack 列表的下方是Scope Variables列表可以查看此时局部变量和全局变量的值。图中可以看出，我们最先走了toggleTab这个方法，然后走到了一个更新对象的方法上，当前调用在哪里，箭头会帮你指向哪里，同时我们可以点击，调用栈列表上的任意一处，即可回头再去看看代码\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225425431?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n但是若你想从新从某个调用方法出执行，可以右键Restart Frame， 断点就会跳到此处开头重新执行，Scope 中的变量值也会依据代码从新更改，这样就可以回退来从新调试，错过的调试也可以回过头来反复查看\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225442825?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\nBreakpoints关于断点：所有当前js的断点都会展示在这个区域，你可以点击按钮用来“去掉/加上”此处断点，也可以点击下方的代码表达式，调到相应的程序代码处，来查看\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225457025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**XHR Breakpoints**\r\n\r\n在XHR Breakpoints处，点击右侧的+号，可以添加请求的URL，一旦 XHR 调用触发时就会在 request.send() 的地方中断\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225516436?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n**DOM Breakpoints:**\r\n\r\n可以给你的DOM元素设置断点，有时候真的需要监听和查看某个元素的变化情况，赋值情况，但是我们并是不太关心哪一段代码对它做的修改，只想看看它的变化情况，那么可以给它来个监听事件，这个时候DOM Breakpoints中会如图\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225533323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n当要给DOM添加断点的时候，会出现选择项分别是如下三种修改1.子节点修改2.自身属性修改3.自身节点被删除。选中之后，Sources Panel 中右侧的 DOM Breakpoints 列表中就会出现该 DOM 断点。一旦执行到要对该 DOM 做相应修改时，代码就会在那里停下来\r\n\r\n**Event listener Breakpoints** \r\n\r\n最后Event Listener 列表，这里列出了各种可能的事件类型。勾选对应的事件类型，当触发了该类型的事件的 [JavaScript](http://lib.csdn.net/base/javascript \"JavaScript知识库\") 代码时就会自动中断\r\n\r\n## <a name=\"t2\"></a>三.Post man你值得拥有的网络请求神器\r\n\r\n在我们的开发过程中，后端的接口都是由发起AJAX请求而获取到的相关数据，但是很多情况是我们的业务还没有做到那块时，后端的同学接口都已经准备好了，但是为了便于后期的工作，将接口请求的数据模拟访问，然后对接口联调很重要，也很方便，因为我们不可能把每个请求代码都写到文件里编译好了再去浏览器内查看，这时候可以安装一个post man网络请求插件，在谷歌应用商店下载，需要翻墙\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225554077?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n该扩展程序使用非常简单，功能同时也非常强大，输入你的请求，选择好请求的method，需要请求参数的挨个填好，send之后，就可以看到返回的数据，这个小工具很利于我们的开发\r\n\r\n![这里写图片描述](http://img.blog.csdn.net/20161228225612057?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZ2wwcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\r\n\r\n文／cayley的编程之路（简书作者） \r\n\r\n原文链接：[http://www.jianshu.com/p/b25c5b88baf5](http://www.jianshu.com/p/b25c5b88baf5) \r\n\r\n著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。\r\n",
        "category" : "xwzj",
        "postSummary" : " 一.先来认识一下这些按钮的功能\r\n\r\n这里写图片描述(http://img.blog.csdn.net/20161228223631938?watermark/2/text/aHR0cDovL2Js...",
        "sub_category" : "tools",
        "img_url" : "",
        "tag" : "debug",
        "recommend" : true,
        "pv" : 16
    },

    /* 33 */
    {
        "_id" : ObjectId("5883301e4dd1690f584edfba"),
        "author" : "yujian666",
        "title" : "大数据展示页面开发",
        "content" : "1、利用mvc模式、bootstrap、backbone、highchart等技术完成展示页面的开发； \r\n\r\n2、项目地址： http://player.xxx.net/\r\n\r\n![](/uploads/works/bigdata.png)",
        "category" : "works",
        "postSummary" : "1、利用mvc模式、bootstrap、backbone、highchart等技术完成展示页面的开发； \r\n\r\n2、项目地址： http://player.xxx.net/\r\n\r\n(/u...",
        "sub_category" : "大数据展示",
        "img_url" : "works/bigdata_20170121182620.png",
        "tag" : "大数据;highcharts;组件化;",
        "recommend" : false,
        "pv" : 23
    },

    /* 34 */
    {
        "_id" : ObjectId("58833ac43cadfe138465c6db"),
        "author" : "yujian666",
        "title" : "美术宝H5播放器",
        "content" : "1.利用h5 video标签开发移动端h5播放器直播与点播功能；  \r\n\r\n2.主要功能点： \r\n\r\nA:对不同浏览器下video播放器样式不一致兼容处理； \r\nB:对ios与andriod对h5播放器事件不一致兼容处理； \r\nC:实现了h5播放的基本功能：播放、暂停、快速、跳过片头片尾、滑动seek、倍数播放、切换视频、弹幕、大数据上报等功能； \r\n\r\n3.播放器使用地址： \r\n\r\nhttp://101.201.238.74:10000/meishubao/webview.html\r\n\r\n![](/uploads/works/20170121.png)",
        "category" : "works",
        "postSummary" : "1.利用h5 video标签开发移动端h5播放器直播与点播功能；  \r\n\r\n2.主要功能点： \r\n\r\nA:对不同浏览器下video播放器样式不一致兼容处理； \r\nB:对ios与andriod对h5播放...",
        "sub_category" : "h5播放器",
        "img_url" : "/works/20170121180556.png",
        "tag" : "h5Video",
        "recommend" : false,
        "pv" : 7
    },

    /* 35 */
    {
        "_id" : ObjectId("588408f527123b0a2c8d019c"),
        "author" : "yujian666",
        "title" : "admin后台管理系统",
        "content" : "1.利用jqueryEasyUI完成公司后台管理系统中的终端用户管理、账单管理、直播管理功能模块的开发； \r\n\r\n2.主要功能点：信息的展示、增删改查、分布、排序、前后端分离等； \r\n\r\n3.项目的stg测试环境地址： \r\nhttp://123.56.30.123:8081/admin/goAdmin.do#/admin/live/channel/index.do\r\n\r\n![](/uploads/works/admincole20170122091305.png)",
        "category" : "works",
        "postSummary" : "1.利用jqueryEasyUI完成公司后台管理系统中的终端用户管理、账单管理、直播管理功能模块的开发； \r\n\r\n2.主要功能点：信息的展示、增删改查、分布、排序、前后端分离等； \r\n\r\n3.项目的s...",
        "sub_category" : "后台管理系统",
        "img_url" : "works/admincole20170122091305.png",
        "tag" : "easyUI",
        "recommend" : false,
        "pv" : 3
    },

    /* 36 */
    {
        "_id" : ObjectId("5884102227123b0a2c8d019d"),
        "author" : "yujian666",
        "title" : "H5宣传页开发",
        "content" : "1.利用rem代替px实现了适配各种终端；\r\n\r\n2.将之前开发的h5播放器集成到宣传页中；\r\n\r\n![](/uploads/works/h5page201701220949.png)\r\n",
        "category" : "works",
        "postSummary" : "1.利用rem代替px实现了适配各种终端；\r\n\r\n2.将之前开发的h5播放器集成到宣传页中；\r\n\r\n(/uploads/works/h5page201701220949.png)\r\n...",
        "sub_category" : "移动端",
        "img_url" : "works/h5page20170122095231.png",
        "tag" : "移动端",
        "recommend" : false,
        "pv" : 3
    },

    /* 37 */
    {
        "_id" : ObjectId("588412d027123b0a2c8d019e"),
        "author" : "yujian666",
        "title" : "个人博客系统",
        "content" : "1.利用node+express+artTemplate+mongodb搭建博客系统；\r\n\r\n2.主要功能点：\r\n登陆、注册、分享、发表文章、markdown语法及时时预览、赞助、搜索、留言、标签系统、分页等；\r\n\r\n3.演示地址： 本网站\r\n\r\n![](/uploads/works/myblog20170122091305.png)",
        "category" : "works",
        "postSummary" : "1.利用nodeexpressartTemplatemongodb搭建博客系统；\r\n\r\n2.主要功能点：\r\n登陆、注册、分享、发表文章、markdown语法及时时预览、赞助、搜索、留言、标签系统、分页...",
        "sub_category" : "nodejs",
        "img_url" : "works/myblog20170122100634.png",
        "tag" : "nodejs;express;artTemplate;mongodb",
        "recommend" : false,
        "pv" : 1
    }
]
for(var i = 0 ; i < mockedData.length; i++){
    var cur = mockedData[i];
    db.getCollection('posts').insert(cur)
    
    }







